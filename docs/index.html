<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <meta name="robots" content="noindex, nofollow">
    <title>Lyftiv - Suivi SÃ©ance Musculation</title>
    
    <style>
        /* CSS Variables for theme and color management (Pastel & Zen Lyftiv Theme) */
        :root {
            /* Background colors - soft, airy blues */
            --bg-grad-start: hsl(200, 60%, 90%); /* Soft Blue */
            --bg-grad-end: hsl(220, 70%, 95%);   /* Lighter Soft Blue */
            
            /* Container & text colors - muted, friendly tones */
            --container-bg: hsla(0, 0%, 100%, 0.9); /* Slightly more opaque white */
            --text-color: hsl(220, 15%, 30%);    /* Darker grey-blue for text */
            --header-color: hsl(220, 20%, 20%);  /* Even darker for headers */
            --border-color: hsl(210, 15%, 88%);  /* Light grey-blue for borders */
            --row-bg-even: hsla(210, 15%, 98%, 0.7); /* Soft off-white for even rows */
            --input-bg: white;
            
            /* Primary buttons - gentle blue/purple gradient (for main actions) */
            --primary-grad-start: hsl(220, 60%, 75%); /* Muted Blue */
            --primary-grad-end: hsl(240, 70%, 80%);   /* Soft Purple */
            
            /* Success (Green) - soft, natural greens (for affirmative actions) */
            --success-grad-start: hsl(140, 60%, 75%); /* Soft Green */
            --success-grad-end: hsl(160, 70%, 80%);   /* Lighter Soft Green */
            --success-color: hsl(140, 50%, 50%);
            
            /* Warning (Orange) - soft, warm oranges (for secondary/neutral actions) */
            --warning-grad-start: hsl(40, 80%, 80%); /* Soft Orange */
            --warning-grad-end: hsl(30, 90%, 85%);   /* Lighter Soft Orange */
            
            /* Danger (Red) - muted, earthy reds/pinks (for destructive actions) */
            --danger-grad-start: hsl(0, 60%, 80%); /* Soft Red */
            --danger-grad-end: hsl(10, 70%, 85%);   /* Lighter Soft Red */
            --danger-color: hsl(0, 60%, 55%);
            
            /* Info (Blue) - soft, light blues (for informational/utility actions) */
            --info-grad-start: hsl(200, 70%, 75%);    /* Soft Light Blue */
            --info-grad-end: hsl(210, 80%, 80%);      /* Lighter Soft Light Blue */
            
            --text-on-color: hsl(220, 20%, 20%); /* Dark text on colored backgrounds for readability */
        }

        body.dark-mode {
            /* Background colors - deep, muted blues */
            --bg-grad-start: hsl(220, 20%, 15%); /* Darker blue-grey */
            --bg-grad-end: hsl(240, 25%, 20%);   /* Slightly lighter blue-grey */
            
            /* Container & text colors - light, contrasting tones */
            --container-bg: hsla(220, 20%, 25%, 0.9); /* Opaque dark container */
            --text-color: hsl(210, 15%, 85%);    /* Light text */
            --header-color: hsl(210, 10%, 70%);  /* Lighter grey-blue for headers */
            --border-color: hsl(210, 10%, 40%);  /* Darker grey for borders */
            --row-bg-even: hsla(220, 20%, 18%, 0.7); /* Darker off-black for even rows */
            --input-bg: hsl(220, 20%, 20%);
            
            /* Primary buttons (dark mode) - muted, deeper versions */
            --primary-grad-start: hsl(220, 25%, 35%); /* Muted Dark Blue */
            --primary-grad-end: hsl(240, 30%, 40%);   /* Muted Dark Purple */
            
            /* Success (dark mode) - muted, deeper versions */
            --success-grad-start: hsl(140, 25%, 35%); /* Muted Dark Green */
            --success-grad-end: hsl(160, 30%, 40%);   /* Lighter Muted Dark Green */
            --success-color: hsl(140, 50%, 65%);
            
            /* Warning (dark mode) - muted, deeper versions */
            --warning-grad-start: hsl(40, 35%, 45%); /* Muted Dark Orange */
            --warning-grad-end: hsl(30, 40%, 50%);   /* Lighter Muted Dark Orange */
            
            /* Danger (dark mode) - muted, deeper versions */
            --danger-grad-start: hsl(0, 30%, 40%); /* Muted Dark Red */
            --danger-grad-end: hsl(10, 35%, 45%);   /* Lighter Muted Dark Red */
            --danger-color: hsl(0, 50%, 65%);
            
            /* Info (dark mode) - muted, deeper versions */
            --info-grad-start: hsl(200, 40%, 45%);    /* Muted Dark Blue */
            --info-grad-end: hsl(210, 45%, 50%);      /* Lighter Muted Dark Blue */

            --text-on-color: hsl(210, 15%, 85%); /* Light text on colored backgrounds */
        }

        /* General styles */
        * { box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif;
            font-size: 16px; 
            line-height: 1.6; 
            margin: 0;
            padding: 1.75rem;
            background: linear-gradient(135deg, var(--bg-grad-start) 0%, var(--bg-grad-end) 100%);
            min-height: 100vh;
            color: var(--text-color);
            transition: background 0.6s ease, color 0.6s ease;
        }
        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            background: var(--container-bg);
            border-radius: 24px;
            padding: 3rem;
            box-shadow: 0 15px 30px hsla(220, 20%, 20%, 0.08);
            backdrop-filter: blur(10px);
            transition: background 0.5s ease;
            position: relative;
        }
        h2 {
            text-align: center;
            color: var(--header-color);
            margin-bottom: 2.25rem;
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.85rem;
        }
        .lyftiv-logo {
            width: 48px;
            height: 48px;
        }
        h3 {
            font-weight: 600;
            font-size: 1.25rem;
            color: var(--header-color);
            margin-bottom: 0.85rem;
            letter-spacing: -0.01em;
        }
        h4 {
             margin: 0 0 0.5rem 0;
            font-size: 1.1rem;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            align-items: center;
            margin-bottom: 1.8rem;
            padding: 1.5rem;
            background: hsla(0, 0%, 100%, 0.1);
            border-radius: 20px;
            box-shadow: 0 3px 8px hsla(220, 20%, 20%, 0.04);
            transition: background 0.5s ease;
        }
        select, input[type="number"], input[type="text"], textarea {
            padding: 0.9rem;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            font-size: 1rem;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-weight: 500;
            width: 100%;
            max-width: 300px;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Inter', sans-serif;
        }
        select:focus, input[type="number"]:focus, input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-grad-start);
            box-shadow: 0 0 0 4px hsla(220, 60%, 75%, 0.3);
        }
        textarea {
            resize: vertical;
            min-height: 110px;
            max-width: 100%;
        }
        .table-container {
            overflow-x: auto;
            border-radius: 20px;
            background: var(--input-bg);
            margin-bottom: 3rem;
            box-shadow: 0 6px 15px hsla(220, 20%, 20%, 0.06);
        }
        table {
            width: 100%;
            border-collapse: separate; 
            border-spacing: 0; 
            /* Corrected: Removed fixed table layout and min-width for responsiveness */
            table-layout: auto; 
            /* min-width: 1010px; */ 
        }
        th, td {
            padding: 1.2rem 0.7rem;
            text-align: center;
            border-bottom: 1px solid var(--border-color); 
            transition: background-color 0.3s ease;
            font-weight: 500;
        }
        th {
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            color: var(--text-on-color);
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 0.85px;
            position: sticky;
            top: 0;
            z-index: 10;
            font-weight: 700;
        }
        th:first-child { border-top-left-radius: 20px; }
        th:last-child { border-top-right-radius: 20px; }

        .exercise-row.superset-group {
            border-left: 4px solid var(--info-grad-end);
        }

        /* Specific column widths adjusted for responsiveness */
        .actions-col { 
            width: max-content; /* Allow content to dictate width */
            padding-left: 0.5rem; /* Adjusted for mobile */
            padding-right: 0.5rem; /* Adjusted for mobile */
        }
        .exercise-col {
            width: 100%; /* Allow it to take available space */
            max-width: 250px; /* Keep a max-width for larger screens */
            text-align: left; 
            padding-left: 0.5rem; /* Adjusted for mobile */
            white-space: normal;
            font-weight: 600; 
        }

        .serie-input {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            align-items: center;
        }
        .serie-input input {
            width: 55px;
            padding: 0.5rem;
            font-size: 0.9rem;
            text-align: center;
            font-weight: 500;
            border-radius: 10px;
        }
        .serie-input input.completed {
            background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end));
            color: var(--text-on-color);
            border-color: var(--success-grad-end);
        }
        .tonnage-high, .onerm-high {
            background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end));
            color: var(--text-on-color);
            border-radius: 10px;
            padding: 0.5rem 0.7rem;
            font-weight: 600;
            font-size: 0.9rem;
            opacity: 0.9;
        }
        .timer-btn {
            padding: 0.8rem 1.4rem;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-on-color);
            transition: all 0.3s ease, box-shadow 0.3s ease; 
            box-shadow: 0 4px 10px hsla(220, 60%, 75%, 0.1);
        }
        .timer-btn:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 6px 12px hsla(220, 60%, 75%, 0.2);
        }
        .timer-btn[data-timer-action="start"] { background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end)); }
        .timer-btn[data-timer-action="stop"] { background: linear-gradient(135deg, var(--danger-grad-start), var(--danger-grad-end)); }
        .timer-btn[data-timer-action="reset"] { background: linear-gradient(135deg, var(--warning-grad-start), var(--warning-grad-end)); }
        .timer-display.timer-active { 
            color: var(--success-grad-start); 
            animation: pulse 1.2s infinite; 
            font-weight: 700;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

        /* Summary section */
        .summary-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.8rem;
            margin-bottom: 3rem;
        }
        .summary-card { 
            padding: 2.2rem;
            border-radius: 20px;
            text-align: center; 
            background: hsla(0, 0%, 100%, 0.1); 
            box-shadow: 0 5px 12px hsla(220, 20%, 20%, 0.05);
        }
        .summary-card .value { 
            font-size: 2.5rem;
            font-weight: 700; 
            color: var(--primary-grad-start);
            letter-spacing: -0.03em;
        }
        body.dark-mode .summary-card .value { color: hsl(220, 60%, 85%); }

        .action-buttons { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 1.5rem;
            justify-content: center; 
            margin-top: 2.5rem; 
        }
        .btn { 
            padding: 1rem 2rem;
            border: none; 
            border-radius: 30px;
            cursor: pointer; 
            font-size: 1rem;
            font-weight: 600; 
            font-family: 'Inter', sans-serif;
            color: var(--text-on-color); 
            transition: all 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 10px hsla(220, 60%, 75%, 0.15);
        }
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 14px hsla(220, 60%, 75%, 0.25);
        }
        .btn-primary { background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end)); }
        .btn-secondary { background: linear-gradient(135deg, var(--warning-grad-start), var(--warning-grad-end)); }
        .btn-danger { background: linear-gradient(135deg, var(--danger-grad-start), var(--danger-grad-end)); }
        .btn-success { background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end)); }
        .btn-info { background: linear-gradient(135deg, var(--info-grad-start), var(--info-grad-end)); }

        /* Notifications */
        .notification { 
            position: fixed; 
            top: 30px; 
            right: 30px; 
            padding: 1.2rem 1.8rem;
            border-radius: 12px;
            color: var(--text-on-color); 
            z-index: 1001; 
            transform: translateX(120%); 
            opacity: 0;
            transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.5s ease; 
            box-shadow: 0 8px 20px hsla(220, 20%, 20%, 0.1);
        }
        .notification.show { 
            transform: translateX(0); 
            opacity: 1;
        }
        .notification.success { background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end)); }
        .notification.error { background: linear-gradient(135deg, var(--danger-grad-start), var(--danger-grad-end)); }
        .notification.info { background: linear-gradient(135deg, var(--info-grad-start), var(--info-grad-end)); }

        /* Modals */
        .modal-overlay { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: hsla(220, 10%, 10%, 0.6);
            display: flex; 
            align-items: center; 
            justify-content: center; 
            z-index: 1000; 
            backdrop-filter: blur(8px);
        }
        .modal-content { 
            background: var(--container-bg); 
            padding: 2.5rem;
            border-radius: 24px;
            max-width: 900px;
            max-height: 90vh; 
            overflow-y: auto; 
            position: relative; 
            box-shadow: 0 20px 40px hsla(220, 20%, 20%, 0.2);
        }
        .modal-close-btn { 
            position: absolute; 
            top: 1rem; 
            right: 1rem; 
            background: transparent; 
            color: var(--text-color); 
            border: none; 
            border-radius: 50%; 
            width: 40px;
            height: 40px; 
            font-size: 1.8rem;
            cursor: pointer; 
            transition: all 0.3s ease;
        }
        .modal-close-btn:hover {
            background-color: var(--border-color);
            transform: rotate(90deg); 
        }

        /* History */
        #historyList { display: flex; flex-direction: column; gap: 1.2rem; }
        .history-item { 
            border: 1px solid var(--border-color); 
            border-radius: 15px;
            padding: 1.4rem;
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            flex-wrap: wrap; 
            gap: 1rem; 
            background: var(--input-bg);
            box-shadow: 0 3px 10px hsla(220, 20%, 20%, 0.04);
            transition: box-shadow 0.3s ease;
        }
        .history-item:hover { box-shadow: 0 5px 15px hsla(220, 20%, 20%, 0.08); }
        .history-details { 
            display: none; 
            width: 100%; 
            margin-top: 1.2rem;
            padding-top: 1.2rem; 
            border-top: 1px solid var(--border-color); 
        }
        .history-details.visible { display: block; }
        .progress-bar { 
            width: 100%; 
            height: 10px;
            background: var(--border-color); 
            border-radius: 5px;
            overflow: hidden; 
            margin: 1.8rem 0;
        }
        .progress-fill { 
            height: 100%; 
            background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end)); 
            border-radius: 5px; 
            transition: width 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .hidden { display: none !important; }

        .theme-switcher { position: absolute; top: 1.5rem; right: 1.5rem; z-index: 11; }
        
        .add-exercise-section {
            display: flex;
            justify-content: center; 
            gap: 1rem;
            margin-top: 1.8rem; 
            padding: 1.5rem; 
            background: hsla(0, 0%, 100%, 0.1); 
            border-radius: 20px; 
            position: relative; 
            align-items: center; 
        }
        .add-exercise-section .input-group {
            display: flex;
            width: 100%;
            max-width: 480px;
            gap: 0.85rem;
        }
        #autocompleteSuggestions {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%); 
            width: 100%; 
            max-width: 480px; 
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 0 0 12px 12px; 
            box-shadow: 0 8px 20px hsla(220, 20%, 20%, 0.1);
            z-index: 20; 
            max-height: 280px;
            overflow-y: auto;
        }
        #autocompleteSuggestions div {
            padding: 0.8rem 1.2rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #autocompleteSuggestions div:hover { background-color: var(--border-color); }
        
        .btn-danger[data-action="remove"] {
            background: none; 
            color: var(--danger-grad-end); 
            padding: 0.4rem 0.7rem; 
            border: none;
            font-size: 1.2rem; 
            opacity: 0.7;
        }
        .btn-danger[data-action="remove"]:hover {
            background: hsla(0, 60%, 80%, 0.15);
            color: var(--danger-grad-start); 
            opacity: 1;
        }
        .quick-edit-btn, .link-btn {
            background: none; border: none; font-size: 1rem; color: var(--info-grad-end);
            cursor: pointer; padding: 0.4rem; border-radius: 8px; transition: all 0.2s ease;
            opacity: 0.8;
        }
        .quick-edit-btn:hover, .link-btn:hover { background-color: hsla(200, 70%, 75%, 0.15); opacity: 1; }
        .link-btn.linking { color: var(--success-grad-start); animation: pulse 1.5s infinite; }
        
        .next-superset-exercise {
            animation: pulse-row 1.5s infinite;
        }
        @keyframes pulse-row {
            0% {
                box-shadow: inset 0 2px 0 0 var(--success-grad-end), inset 0 -2px 0 0 var(--success-grad-end);
            }
            50% {
                box-shadow: inset 0 2px 0 0 transparent, inset 0 -2px 0 0 transparent;
            }
            100% {
                box-shadow: inset 0 2px 0 0 var(--success-grad-end), inset 0 -2px 0 0 var(--success-grad-end);
            }
        }
        
        /* New Styles for Calculator Modal Tabs and Goal Cards */
        .modal-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1.5rem;
        }
        .modal-tab-btn {
            padding: 0.8rem 1.5rem;
            cursor: pointer;
            border: none;
            background-color: transparent;
            color: var(--text-color);
            font-weight: 600;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }
        .modal-tab-btn.active {
            color: var(--primary-grad-start);
            border-bottom-color: var(--primary-grad-start);
        }
        #goalResultsContainer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        .goal-card {
            background-color: var(--input-bg);
            border-radius: 15px;
            padding: 1.5rem;
            text-align: center;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 10px hsla(220, 20%, 20%, 0.05);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
        }
        .goal-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px hsla(220, 20%, 20%, 0.1);
        }
        .goal-card h4 {
            margin: 0 0 0.5rem 0;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .goal-card .icon {
            font-size: 1.5rem;
        }
        .goal-card .weight-range {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--success-grad-start);
        }
        .goal-card .rep-range {
            font-size: 0.9rem;
            color: var(--text-color);
            opacity: 0.8;
            margin-top: 0.5rem;
        }
        .goal-card.hypertrophy { border-left: 5px solid hsl(260, 70%, 75%); }
        .goal-card.strength { border-left: 5px solid hsl(0, 70%, 75%); }
        .goal-card.endurance { border-left: 5px solid hsl(40, 90%, 75%); }
        .goal-card.power { border-left: 5px solid hsl(200, 80%, 75%); }

        .plate-result-message {
            font-weight: bold;
        }
        .plate-result-message.success {
            color: var(--success-color);
        }
        .plate-result-message.danger {
            color: var(--danger-color);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            body { padding: 1rem; padding-bottom: 80px; }
            .main-container { padding: 1.5rem; }
            h2 { font-size: 2rem; }
            .lyftiv-logo { width: 40px; height: 40px; }
            .controls, .add-exercise-section { flex-direction: column; }
            /* Removed min-width from table on mobile to allow it to shrink */
            table { min-width: unset; } 
            th, td { padding: 0.8rem 0.4rem; font-size: 0.75rem; } /* Adjusted padding and font size for mobile */
            .action-buttons { flex-direction: column; gap: 1rem; }
            .btn { width: 100%; }
            .notification { width: calc(100% - 2rem); left: 1rem; right: 1rem; top: 1rem; }
            .modal-content { width: calc(100% - 2rem); margin: 1rem; padding: 1.5rem; }
            .serie-input input { /* Adjusted input width for mobile */
                width: 45px; 
                padding: 0.3rem;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="theme-switcher">
            <button id="themeToggleBtn" class="btn btn-primary" aria-label="Changer de thÃ¨me">ð</button>
        </div>
        <h2>
            <svg class="lyftiv-logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="lyftivLogoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stop-color="hsl(200, 80%, 85%)" />
                        <stop offset="100%" stop-color="hsl(260, 60%, 85%)" />
                    </linearGradient>
                </defs>
                <rect x="0" y="0" width="100" height="100" rx="20" ry="20" fill="url(#lyftivLogoGradient)"/>
                <path d="M 15 50 C 15 35 30 30 50 30 C 70 30 85 35 85 50 C 85 65 70 70 50 70 C 30 70 15 65 15 50 Z M 25 50 L 75 50 M 25 35 L 25 65 M 75 35 L 75 65" stroke="hsl(220, 60%, 55%)" stroke-width="3.5" fill="none" stroke-linecap="round"/>
                <circle cx="25" cy="50" r="14" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="25" cy="50" r="10" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="25" cy="50" r="6" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="75" cy="50" r="14" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="75" cy="50" r="10" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="75" cy="50" r="6" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <rect x="35" y="48.5" width="30" height="3" rx="1.5" ry="1.5" fill="white"/>
            </svg>
            Lyftiv
        </h2>
        
        <div class="controls">
          <label for="sessionSelect"><strong>SÃ©ance:</strong></label>
          <select id="sessionSelect">
            <option value="0">PUSH (Poitrine/Ãpaules/Triceps)</option>
            <option value="1">PULL (Dos/Biceps)</option>
            <option value="2">LEG (Jambes)</option>
            <option value="3">Ãpaules/Bras</option>
            <option value="4">Dos/Pec</option>
          </select>
          <button class="btn btn-primary" id="createNewSessionTypeBtn" aria-label="CrÃ©er une nouvelle sÃ©ance">Nouvelle SÃ©ance</button>
        </div>
        
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <div class="table-container">
          <table id="workoutTable">
            <thead>
              <tr>
                <th class="actions-col">Actions</th>
                <th>Exercice</th>
                <th colspan="5">SÃ©ries</th>
                <th>Tonnage</th>
                <th>1RM</th>
                <th>Repos</th>
                <th>Minuteur</th>
                <th></th> 
              </tr>
            </thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>
        
        <section class="controls add-exercise-section">
            <div class="input-group">
                <input type="text" id="customExercise" placeholder="Ajouter un exercice" aria-label="Nom de l'exercice personnalisÃ©">
                <button class="btn btn-success" id="addExerciseBtn" aria-label="Ajouter l'exercice">+</button>
            </div>
            <div id="autocompleteSuggestions"></div>
        </section>

        <section class="summary-section">
            <div class="summary-card">
                <h3>ðï¸ Tonnage Total</h3>
                <div class="value" id="totalTonnage">0 kg</div>
            </div>
            <div class="summary-card">
                <h3>ð Semaine PrÃ©cÃ©dente</h3>
                <input type="text" id="previousWeek" placeholder="Tonnage PrÃ©c. (kg)" aria-label="Tonnage de la semaine prÃ©cÃ©dente">
            </div>
            <div class="summary-card">
                <h3>ð Progression</h3>
                <div class="value" id="delta">0 kg</div>
            </div>
            <div class="summary-card">
                <h3>â±ï¸ Temps Total</h3>
                <div class="value" id="totalTime">00:00:00</div>
                <button id="toggleWorkoutTimerBtn" class="btn btn-primary" aria-label="Mettre en pause ou reprendre le minuteur" style="margin-top: 1rem;">â¯ï¸ Pause</button>
            </div>
        </section>

        <section class="controls" style="margin-top: 1rem;">
            <label for="sessionNotes"><strong>Notes de SÃ©ance:</strong></label>
            <textarea id="sessionNotes" placeholder="Ajouter des notes sur la sÃ©ance..." aria-label="Notes de sÃ©ance"></textarea>
        </section>
        
        <nav class="action-buttons">
          <button class="btn btn-success" id="finishSessionBtn" aria-label="Terminer et Sauvegarder la sÃ©ance">Terminer et Sauvegarder</button>
          <button class="btn btn-primary" id="viewHistoryBtn" aria-label="Voir l'historique">ð Historique</button>
          <button class="btn btn-primary" id="plateCalculatorBtn" aria-label="Ouvrir les calculateurs">ð§® Calculateurs</button>
          <button class="btn btn-info" id="exportBtn" aria-label="Exporter les donnÃ©es">ð Exporter</button>
          <button class="btn btn-info" id="importBtn" aria-label="Importer les donnÃ©es">ð¥ Importer</button>
        </nav>
        <input type="file" id="importFile" class="hidden" accept=".json,.csv">
    </div>
    
    <div id="notification-container"></div>
    
    <div id="historyModal" class="modal-overlay hidden">
      <div class="modal-content">
          <button id="closeHistoryModal" class="modal-close-btn" aria-label="Fermer le modal historique">&times;</button>
          <h2>Historique des SÃ©ances</h2>
          <div id="historyList"></div>
      </div>
    </div>

    <div id="newSessionModal" class="modal-overlay hidden">
        <div class="modal-content">
            <button id="closeNewSessionModal" class="modal-close-btn" aria-label="Fermer le modal de nouvelle sÃ©ance">&times;</button>
            <h2>CrÃ©er une Nouvelle SÃ©ance</h2>
            <input type="text" id="newSessionNameInput" placeholder="Nom de la nouvelle sÃ©ance" aria-label="Nom de la nouvelle sÃ©ance">
            <div style="display: flex; justify-content: center; gap: 1rem; margin-top: 1.5rem;">
                <button class="btn btn-secondary" id="cancelNewSessionBtn">Annuler</button>
                <button class="btn btn-success" id="createNewSessionBtn">CrÃ©er</button>
            </div>
        </div>
    </div>

    <div id="loadOptionsModal" class="modal-overlay hidden">
      <div class="modal-content">
          <button id="closeLoadOptionsModal" class="modal-close-btn" aria-label="Fermer le modal d'options de chargement">&times;</button>
          <h2>Options de Chargement</h2>
          <p>Comment utiliser la sÃ©ance "<strong id="loadSessionName"></strong>" ?</p>
          <div style="display: flex; justify-content: center; gap: 1rem; margin-top: 1.5rem;">
              <button class="btn btn-primary" id="openNewSessionBtn">Ouvrir (remplace la sÃ©ance actuelle)</button>
              <button class="btn btn-secondary" id="appendToCurrentSessionBtn">Ajouter Ã  la sÃ©ance actuelle</button>
          </div>
      </div>
    </div>

    <div id="plateCalculatorModal" class="modal-overlay hidden">
        <div class="modal-content">
            <button id="closePlateCalculatorModal" class="modal-close-btn" aria-label="Fermer le modal du calculateur de plaques">&times;</button>
            <div class="modal-tabs">
                <button class="modal-tab-btn active" id="plateCalcTab">Calculateur de Plaques</button>
                <button class="modal-tab-btn" id="goalCalcTab">Objectifs d'EntraÃ®nement</button>
            </div>
            
            <div id="plateCalcContent" class="modal-tab-content">
                <h2>Calculateur de Plaques</h2>
                <div class="plate-calculator-inputs">
                    <input type="number" id="targetWeightInput" min="0" placeholder="Poids cible (kg)" aria-label="Poids cible">
                    <input type="number" id="barbellWeightInput" min="0" placeholder="Poids barre (kg)" aria-label="Poids de la barre">
                </div>
                <div id="platesResult" style="text-align: left; margin-top: 1.5rem;"></div>
            </div>

            <div id="goalCalcContent" class="modal-tab-content hidden">
                <h2>Objectifs d'EntraÃ®nement</h2>
                <div class="plate-calculator-inputs">
                    <input type="number" id="oneRmInput" min="0" placeholder="Votre 1RM (kg)" aria-label="Votre 1RM">
                </div>
                <div id="goalResultsContainer"></div>
            </div>
        </div>
    </div>
    
    <div id="quickEditModal" class="modal-overlay hidden">
      <div class="modal-content">
          <button id="closeQuickEditModal" class="modal-close-btn" aria-label="Fermer le modal d'Ã©dition rapide">&times;</button>
          <h2>Ãdition Rapide</h2>
          <p>Appliquer Ã  toutes les sÃ©ries de : <strong id="quickEditExerciseName"></strong></p>
          <div class="plate-calculator-inputs">
              <input type="text" id="quickEditWeight" placeholder="Poids (kg)" aria-label="Poids pour Ã©dition rapide">
              <input type="text" id="quickEditReps" placeholder="Reps" aria-label="RÃ©pÃ©titions pour Ã©dition rapide">
          </div>
          <button class="btn btn-success" id="applyQuickEditBtn" style="width: 100%;">Appliquer</button>
      </div>
    </div>

    <script>
    window.addEventListener('load', () => {

        const dom = {
            sessionSelect: document.getElementById('sessionSelect'),
            tbody: document.getElementById('tbody'),
            totalTonnageEl: document.getElementById('totalTonnage'),
            previousWeekInput: document.getElementById('previousWeek'),
            deltaEl: document.getElementById('delta'),
            totalTimeEl: document.getElementById('totalTime'),
            progressFill: document.getElementById('progressFill'),
            historyModal: document.getElementById('historyModal'),
            notificationContainer: document.getElementById('notification-container'),
            customExerciseInput: document.getElementById('customExercise'),
            historyList: document.getElementById('historyList'),
            importFileInput: document.getElementById('importFile'),
            themeToggleBtn: document.getElementById('themeToggleBtn'),
            body: document.body,
            toggleWorkoutTimerBtn: document.getElementById('toggleWorkoutTimerBtn'),
            newSessionModal: document.getElementById('newSessionModal'),
            closeNewSessionModal: document.getElementById('closeNewSessionModal'),
            newSessionNameInput: document.getElementById('newSessionNameInput'),
            cancelNewSessionBtn: document.getElementById('cancelNewSessionBtn'),
            createNewSessionBtn: document.getElementById('createNewSessionBtn'),
            createNewSessionTypeBtn: document.getElementById('createNewSessionTypeBtn'),
            loadOptionsModal: document.getElementById('loadOptionsModal'),
            closeLoadOptionsModal: document.getElementById('closeLoadOptionsModal'),
            loadSessionNameDisplay: document.getElementById('loadSessionName'),
            openNewSessionBtn: document.getElementById('openNewSessionBtn'),
            appendToCurrentSessionBtn: document.getElementById('appendToCurrentSessionBtn'),
            autocompleteSuggestions: document.getElementById('autocompleteSuggestions'),
            plateCalculatorModal: document.getElementById('plateCalculatorModal'),
            closePlateCalculatorModal: document.getElementById('closePlateCalculatorModal'),
            plateCalculatorBtn: document.getElementById('plateCalculatorBtn'),
            targetWeightInput: document.getElementById('targetWeightInput'),
            barbellWeightInput: document.getElementById('barbellWeightInput'),
            platesResult: document.getElementById('platesResult'),
            sessionNotesInput: document.getElementById('sessionNotes'),
            quickEditModal: document.getElementById('quickEditModal'),
            closeQuickEditModal: document.getElementById('closeQuickEditModal'),
            quickEditExerciseName: document.getElementById('quickEditExerciseName'),
            quickEditWeight: document.getElementById('quickEditWeight'),
            quickEditReps: document.getElementById('quickEditReps'),
            applyQuickEditBtn: document.getElementById('applyQuickEditBtn'),
            plateCalcTab: document.getElementById('plateCalcTab'),
            goalCalcTab: document.getElementById('goalCalcTab'),
            plateCalcContent: document.getElementById('plateCalcContent'),
            goalCalcContent: document.getElementById('goalCalcContent'),
            oneRmInput: document.getElementById('oneRmInput'),
            goalResultsContainer: document.getElementById('goalResultsContainer'),
        };

        let state = {
            sessions: [], 
            currentSessionIndex: 0,
            timers: {},
            workoutStartTime: null,
            totalWorkoutTimeInterval: null,
            isWorkoutTimerPaused: false,
            pausedTime: 0,
            sessionToLoad: null,
            availableExercises: [],
            lastDeletedExercise: null,
            inactivityTimeout: null, 
            autoSaveInterval: null, 
            linkingState: { active: false, fromIndex: null }, 
            quickEditIndex: null
        };
        
        const defaultSessions = [
            { name: "PUSH (Poitrine/Ãpaules/Triceps)", exercises: [
                { name: "DC barre lourd", rest: "2 min" }, { name: "DC barre lÃ©ger", rest: "2 min" }, { name: "InclinÃ© haltÃ¨res", rest: "1 min" }, { name: "ÃcartÃ© vis Ã  vis", rest: "1 min" }, { name: "Dips machine", rest: "1 min" }, { name: "ÃlÃ©vation latÃ©rale machine debout", rest: "1 min" }, { name: "Extension triceps poulie", rest: "1 min" }
            ]},
            { name: "PULL (Dos/Biceps)", exercises: [
                { name: "Traction", rest: "2 min" }, { name: "Pull poulie", rest: "1 min" }, { name: "Tirage uni poulie haute sur banc", rest: "1 min" }, { name: "Rowing T bar", rest: "1 min" }, { name: "Machine Row", rest: "1 min" }, { name: "Machine Row uni", rest: "1 min" }, { name: "Face pull", rest: "1 min" }, { name: "Oiseaux machine", rest: "1 min" }, { name: "Curl marteau simultanÃ©", rest: "1 min" }, { name: "Bayesian curl", rest: "1 min" }
            ]},
            { name: "LEG (Jambes)", exercises: [
                { name: "Leg extension drop", rest: "1 min" }, { name: "Presse horizontal", rest: "2 min" }, { name: "Squat guidÃ© lÃ©ger", rest: "1 min" }, { name: "Fente marchÃ©", rest: "2 min" }, { name: "Leg Curl assis", rest: "1 min" }, { name: "SDT jambes tendues smith", rest: "1 min" }
            ]},
            { name: "Ãpaules/Bras", exercises: [
                { name: "Militaire haltÃ¨res pyramide montante", rest: "3 min" }, { name: "ÃlÃ©vation latÃ©rale", rest: "1 min" }, { name: "ÃlÃ©vation latÃ©rale supination", rest: "1 min" }, { name: "Face pull", rest: "1 min" }, { name: "Extension triceps", rest: "1 min" }, { name: "Curl poulie basse", rest: "1 min" }, { name: "Magic triceps", rest: "1 min" }, { name: "Curl pupitre", rest: "1 min" }, { name: "Dips", rest: "1 min" }, { name: "Curl haltÃ¨res inclinÃ©", rest: "1 min" }, { name: "Cross Cable Triceps", rest: "1 min" }, { name: "Curl concentrÃ© haltÃ¨re", rest: "1 min" }
            ]},
            { name: "Dos/Pec", exercises: [
                 { name: "Tirage horizontal", rest: "1 min" }, { name: "Rowing barre buste penchÃ© pronation", rest: "1 min" }, { name: "Tirage poulie basse avec corde", rest: "1 min" }, { name: "InclinÃ© guidÃ©", rest: "2 min" }, { name: "ÃcartÃ© couchÃ©", rest: "1 min" }, { name: "Vis Ã  vis sur banc inclinÃ©", rest: "1 min" }, { name: "Circuit abdos", rest: "1 min" }
            ]}
        ];
        
        const rawExerciseList = `
ABS rolls
Abdos couchÃ©
Abducteurs
Adducteurs
Adduction poulie jambe pliÃ©e
Archer row
Arnold press
Ball slam
Ball slam cÃ´tÃ©
Bar hang
Bayesian curl
Bear push up
Biceps anneaux
Biceps-triceps extension superset
Bird dog
Bobine d'Andrieu
Bobine d'Andrieu inversÃ©e
Brignole cable press down
Brignole squat
Burpees
Cable crunch
Cable extension jambe
Cable glute kickback
Cable jambe Ã©tendue
Cable kickback
Cable leg extension
Cable press down
Cable cable press down brignole
Calf raise machine
Cat camel
Chest flies
Chest flies machine
Circuit cross training
Corde Ã  sauter
Course sur tapis
Crunch
Crunch classique
Curl barre EZ
Curl inclinÃ©
Curl marteau assis
Curl pronation
Curl pronation haltÃ¨res
Curl pupitre
Curl pupitre machine
Deadbug
Deadlift trap bar
Dips
Dips pectoraux anneaux
Dips verticaux barres fixes
Donkey kick
Drapeau humain
Drop jump single leg
DÃ©v. couchÃ© partiel prise serrÃ©e
DÃ©v. inclinÃ©
DÃ©v. militaire assis haltÃ¨res
DÃ©veloppÃ© couchÃ©
DÃ©veloppÃ© couchÃ© haltÃ¨res
DÃ©veloppÃ© couchÃ© inclinÃ© haltÃ¨res
DÃ©veloppÃ© devant landmine
DÃ©veloppÃ© militaire
DÃ©veloppÃ© militaire barre
DÃ©veloppÃ© militaire haltÃ¨re
Elevations tibialis
Extension haltÃ¨res en hauteur
Extension triceps corde
Extension triceps Ã©lastique
Facepull
Facepull anneaux
Fentes bulgares
Fentes marchÃ©es
Flexion haltÃ¨res en hauteur
Floor press haltÃ¨res
Fly au sol bras Ã  60Â°
Front Squats
Front lever
Gainage rÃ©troversion
Glute bridge
Glute extension
Glute ham raise
Glute kickback
High lat pull in
Hip thrust une jambe
Hula hoop
Inverted row
Jump squats
Jumping jacks
L-Fly
L-fly poulie
L-fly Ã©lastique
Landmine press
Landmine squat
Landmine squeeze press
Lat prayer
Leg curl allongÃ©
Leg curl assis
Leg curl delavier
Leg curl haltÃ¨res
Leg curl machine
Leg extension
Machine arriÃ¨re Ã©paules
Machine rowing divergent
Magyc triceps
Masse de force
ForceMedecine ball wall slam
Medicine ball wall slam
Modified row
Mollets assis
Mollets assis barre
Mollets assis machine
Mollets debout
Mollets machine
Mollets Ã  la barre guidÃ©e
Mollets Ã  la presse Ã  cuisse
MontÃ©e de marches
Mountain climbers
Multi-hip
Musclets
Nordic hamstring
Oiseau
Oiseau poulie/anneaux
Oiseaux poulie
Pec deck
Pendlay row
Pistol assistÃ©
Plank
Pompes archer
Pompes complÃ¨tes
Pompes pliomÃ©triques
Pompes sur anneaux
PortÃ©e de grosse pierre
PoussÃ©e de poulie diagonale haute
PoussÃ©e de rouleau dans le mur
Presse Palof
Presse inclinÃ©e
Pull over haltÃ¨res
Rack push
RelevÃ© de jambes suspendu
RetournÃ© de pneu
Romanian Deadlift
Romanian deadlift
Rowing Yates
Rowing bÃ»cheron
Rowing divergent
Rowing haltÃ¨res
Rowing uneven
Side bend
Side bend Ã©lastique
Side plank dynamique
Single leg hipthrust landmine
Single leg stiff leg deadlift
Sissy Mathias
Sissy squat
Sissy squat anneaux
Sissy squat appui anneaux
Sissy squat machine
Skull crusher
Sled push
Sprint
Sprint en montÃ©e
Squat barre
Squat talons trÃ¨s relevÃ©s
Standing cable leg curl
Step up
Step up accrochÃ©
Superman
Superset Crunch/relevÃ© de jambes
Swing kettlebell + Ã©lastique
Swings
Tibialis anterior
Tirage arrachÃ©
Tirage horizontal
Tirage vertical machine
Tirage vertical unilatÃ©ral
Tire flip
Traction assistÃ©e
Traction supination
Tractions anneaux
Tractions porte
Tractions prise neutre focus coude
Tractions pronation
Tractions pronation prise serrÃ©e
Tractions scapulaires
Tractions scapulaires uneven
Tractions supination
Triceps anneaux
Triceps au mur
Triceps poulie
Unilateral lat pull in
Upright row
Wall ball
Wall ball devant
Wall ball diagonal
Wall ball frisbee
Woodchopper
ÃcartÃ© couchÃ© haltÃ¨res
ÃcartÃ© poulie haute
ÃlÃ©vation frontale
ÃlÃ©vations latÃ©rales
ÃlÃ©vations latÃ©rales couchÃ©es
ÃlÃ©vations latÃ©rales poulie
ÃlÃ©vations latÃ©rales unilatÃ©rale
ÃlÃ©vations mollets debout
        `;
        
        // ===================================================================
        // ALL FUNCTION DEFINITIONS
        // ===================================================================
        
        function handleRepInput(e) {
            const input = e.target;
            let value = input.value.replace(',', '.');
            let parsedValue = parseFloat(value);
            
            if (isNaN(parsedValue) || parsedValue < 0) {
                input.value = '';
                return;
            }
            
            let roundedValue = Math.round(parsedValue * 2) / 2;
            input.value = roundedValue;
        }

        function getPlateCombinationOptimal(target, denominations) {
            let currentRemaining = target;
            const platesUsed = {};
            let loadedWeight = 0;
            for (const plateValue of denominations) {
                const numPlates = Math.floor(currentRemaining / plateValue);
                if (numPlates > 0) {
                    platesUsed[plateValue] = numPlates;
                    loadedWeight += numPlates * plateValue;
                    currentRemaining -= (numPlates * plateValue);
                    currentRemaining = parseFloat(currentRemaining.toFixed(2)); 
                }
            }
            return { plates: platesUsed, loadedWeight: loadedWeight, remaining: currentRemaining };
        }

        function getPlateCombinationAlternative(target, fullDenominations) {
            let currentRemaining = target;
            const platesUsed = {};
            const alternativeOrder = [10, 5, 20, 15, 2.5, 1.25, 0.5, 0.25]; // Changed order
            const availableAlternativeOrder = alternativeOrder.filter(p => fullDenominations.includes(p));
            for (const plateValue of availableAlternativeOrder) {
                if (currentRemaining <= 0) break; 
                const numPlates = Math.floor(currentRemaining / plateValue);
                if (numPlates > 0) {
                    platesUsed[plateValue] = (platesUsed[plateValue] || 0) + numPlates;
                    currentRemaining -= numPlates * plateValue;
                    currentRemaining = parseFloat(currentRemaining.toFixed(2)); 
                }
            }
            let loadedWeight = target - currentRemaining; 
            return { plates: platesUsed, loadedWeight: loadedWeight, remaining: currentRemaining };
        }

        function formatPlatesWithPlus(platesObject) {
            let formatted = [];
            const sortedPlateValues = Object.keys(platesObject).map(Number).sort((a, b) => b - a);
            for (const plateValue of sortedPlateValues) {
                if (platesObject[plateValue] > 0) {
                    formatted.push(`<span>${plateValue}kg x${platesObject[plateValue]}</span>`); 
                }
            }
            return formatted.length > 0 ? formatted.join(' + ') : 'Aucun';
        }
        
        function calculatePlates() {
            const targetWeight = parseFloat(dom.targetWeightInput.value);
            const barbellWeight = parseFloat(dom.barbellWeightInput.value);
            if (isNaN(targetWeight) || isNaN(barbellWeight) || targetWeight < 0 || barbellWeight < 0 || barbellWeight > targetWeight) {
                dom.platesResult.innerHTML = "<p>Veuillez entrer des poids valides.</p>";
                return;
            }
            let weightPerSideTarget = (targetWeight - barbellWeight) / 2;
            if (weightPerSideTarget < 0) {
                 dom.platesResult.innerHTML = `<p class="plate-result-message danger">Le poids cible doit Ãªtre supÃ©rieur ou Ã©gal au poids de la barre.</p>`;
                 return;
            }
            const platesDenominations = [25, 20, 15, 10, 5, 2.5, 1.25, 0.5, 0.25].sort((a, b) => b - a);
            const combinationResult1 = getPlateCombinationOptimal(weightPerSideTarget, platesDenominations);
            const formattedPlates1 = formatPlatesWithPlus(combinationResult1.plates);
            const combinationResult2 = getPlateCombinationAlternative(weightPerSideTarget, platesDenominations);
            const formattedPlates2 = formatPlatesWithPlus(combinationResult2.plates);

            const loadedWeightPerSide = combinationResult1.loadedWeight;
            const totalLoadedWeight = loadedWeightPerSide * 2 + barbellWeight;
            const diff = targetWeight - totalLoadedWeight;

            let resultHtml = `<div class="result-summary">
                                <h3>RÃ©sultats :</h3>
                                <p>Poids chargÃ© par cÃ´tÃ©: <span>${loadedWeightPerSide.toFixed(2)}kg</span> | Poids total chargÃ©: <span>${totalLoadedWeight.toFixed(2)}kg</span></p>`;
            
            if (Math.abs(diff) < 0.01) {
                resultHtml += `<p class="plate-result-message success">Poids cible atteint !</p>`;
            } else {
                resultHtml += `<p class="plate-result-message danger">DiffÃ©rence par rapport Ã  la cible: +${diff.toFixed(2)}kg (manquant)</p>`;
            }
            resultHtml += `</div>`;
            resultHtml += `<h4>1. Minimisant le nombre de plaques:</h4><p>${formattedPlates1}</p>`;
            if(formattedPlates1 !== formattedPlates2 && formattedPlates2 !== 'Aucun') {
                resultHtml += `<h4>2. DÃ©composition dÃ©taillÃ©e:</h4><p>${formattedPlates2}</p>`;
            }
            
            dom.platesResult.innerHTML = resultHtml;
        }

        function calculateTrainingGoals() {
            const oneRm = parseFloat(dom.oneRmInput.value);
            if (isNaN(oneRm) || oneRm <= 0) {
                dom.goalResultsContainer.innerHTML = '';
                return;
            }

            const goals = [
                { name: 'Hypertrophie', icon: 'ðª', minPercent: 0.60, maxPercent: 0.80, a_class: 'hypertrophy', tooltip: '60-80% du 1RM', reps: '6-12 RÃ©pÃ©titions' },
                { name: 'Force', icon: 'ð¥', minPercent: 0.80, maxPercent: 1.00, a_class: 'strength', tooltip: '80-100% du 1RM', reps: '1-5 RÃ©pÃ©titions' },
                { name: 'Endurance', icon: 'ðââï¸', minPercent: 0, maxPercent: 0.60, a_class: 'endurance', tooltip: '<60% du 1RM', reps: '15+ RÃ©pÃ©titions' },
                { name: 'Power', icon: 'â¡', minPercent: 0.30, maxPercent: 0.70, a_class: 'power', tooltip: '30-70% du 1RM', reps: '3-6 RÃ©pÃ©titions (explosif)' }
            ];

            let resultsHtml = '';
            goals.forEach(goal => {
                const minWeight = (oneRm * goal.minPercent).toFixed(1);
                const maxWeight = (oneRm * goal.maxPercent).toFixed(1);
                let rangeText;
                if (goal.minPercent === 0) {
                    rangeText = `< ${maxWeight} kg`;
                } else {
                    rangeText = `${minWeight} - ${maxWeight} kg`;
                }

                resultsHtml += `
                    <div class="goal-card ${goal.a_class}" title="${goal.tooltip}">
                        <h4><span class="icon">${goal.icon}</span> ${goal.name}</h4>
                        <div class="weight-range">${rangeText}</div>
                        <p class="rep-range">${goal.reps}</p>
                    </div>
                `;
            });

            dom.goalResultsContainer.innerHTML = resultsHtml;
        }
        
        async function handleTableActions(e) { 
            const button = e.target.closest('button');
            if (!button) return;
            const row = button.closest('.exercise-row');
            if (!row) return;
            const idx = +row.dataset.exerciseIndex;
            const timerAction = button.dataset.timerAction;
            const action = button.dataset.action;
            if (action === 'quick-edit') {
                state.quickEditIndex = idx;
                dom.quickEditExerciseName.textContent = state.sessions[state.currentSessionIndex].exercises[idx].name;
                dom.quickEditModal.classList.remove('hidden');
                dom.quickEditWeight.focus();
            } else if (action === 'link-superset') {
                const linkBtn = button;
                if (!state.linkingState.active) {
                    state.linkingState.active = true;
                    state.linkingState.fromIndex = idx;
                    linkBtn.classList.add('linking');
                    showNotification("SÃ©lectionnez un autre exercice Ã  lier.", "info");
                } else {
                    if (state.linkingState.fromIndex !== idx) {
                        const exercises = state.sessions[state.currentSessionIndex].exercises;
                        const fromEx = exercises[state.linkingState.fromIndex];
                        const toEx = exercises[idx];

                        if (fromEx && toEx) {
                            fromEx.supersetWith = idx;
                            toEx.supersetGroup = true; // Mark both exercises as part of a group
                            fromEx.supersetGroup = true;
                            showNotification("Exercices liÃ©s en superset !", "success");
                        } else {
                            showNotification("Erreur lors de la liaison des exercices.", "error");
                        }
                    }
                    const prevLinkBtn = dom.tbody.querySelector(`[data-exercise-index="${state.linkingState.fromIndex}"] .link-btn`);
                    if(prevLinkBtn) prevLinkBtn.classList.remove('linking');
                    state.linkingState = { active: false, fromIndex: null };
                    createTable();
                }
            } else if (timerAction) {
                handleTimerActions(timerAction, idx, row);
            } else if (action === 'remove') {
                const exerciseToRemove = state.sessions[state.currentSessionIndex].exercises[idx];
                const confirmed = await customConfirm(`Supprimer "${exerciseToRemove.name}"?`);
                if (confirmed) {
                    state.sessions[state.currentSessionIndex].exercises.splice(idx, 1);
                    state.lastDeletedExercise = exerciseToRemove; 
                    if (state.timers[idx]) {
                        clearInterval(state.timers[idx].interval);
                        delete state.timers[idx];
                    }
                    createTable(); 
                    showUndoableNotification(`Exercice "${exerciseToRemove.name}" supprimÃ©.`, () => {
                        if (state.lastDeletedExercise) {
                            state.sessions[state.currentSessionIndex].exercises.splice(idx, 0, state.lastDeletedExercise);
                            createTable();
                            updateAllTotals(); 
                            state.lastDeletedExercise = null; 
                            showNotification(`Suppression annulÃ©e. "${exerciseToRemove.name}" restaurÃ©.`, "info");
                        }
                    }, 7000); 
                }
            }
        }
        
        function handleTimerActions(timerAction, idx, row) {
             const timerDisplay = row.querySelector('.timer-display');
             const startBtn = row.querySelector('[data-timer-action="start"]');
             const stopBtn = row.querySelector('[data-timer-action="stop"]');
             const exercise = state.sessions[state.currentSessionIndex].exercises[idx];
             const restString = exercise.rest;
             let restSeconds = parseInt(restString) * (restString.includes('min') ? 60 : 1) || 60;
             const duration = Math.max(restSeconds, 60); 

            if (timerAction === 'start') {
                const endTime = Date.now() + duration * 1000;
                localStorage.setItem(`timer-${idx}`, JSON.stringify({ endTime, name: exercise.name }));
                
                if (state.timers[idx] && state.timers[idx].interval) clearInterval(state.timers[idx].interval);
                state.timers[idx] = {
                    secondsElapsed: 0,
                    duration: duration,
                    interval: setInterval(() => {
                        state.timers[idx].secondsElapsed++;
                        const remaining = state.timers[idx].duration - state.timers[idx].secondsElapsed;
                        if (remaining <= 0) {
                            timerDisplay.textContent = "0:00";
                            timerDisplay.classList.remove('timer-active');
                            clearInterval(state.timers[idx].interval);
                            localStorage.removeItem(`timer-${idx}`);
                            playBeep(); 
                            if(Notification.permission === "granted") {
                                new Notification('Lyftiv - Repos TerminÃ© !', { body: `Le temps de repos pour ${exercise.name} est terminÃ©.`});
                            }
                            startBtn.classList.remove('hidden'); 
                            stopBtn.classList.add('hidden'); 
                            
                            // NEW SUPERSET LOGIC
                            const exercises = state.sessions[state.currentSessionIndex].exercises;
                            const parentIndex = exercises.findIndex(ex => ex.supersetWith === idx);
                            if (parentIndex !== -1) {
                                const parentExercise = exercises[parentIndex];
                                const parentRow = dom.tbody.querySelector(`[data-exercise-index="${parentIndex}"]`);
                                parentRow?.classList.add('next-superset-exercise');
                                showNotification(`Fin du repos ! Reprenez avec ${parentExercise.name}`, "info");
                            }

                        } else {
                            timerDisplay.textContent = formatTimerDisplay(remaining); 
                        }
                    }, 1000) 
                };
                timerDisplay.textContent = formatTimerDisplay(duration); 
                timerDisplay.classList.add('timer-active'); 
                startBtn.classList.add('hidden'); 
                stopBtn.classList.remove('hidden'); 
            } else if (timerAction === 'stop' || timerAction === 'reset') {
                if (state.timers[idx] && state.timers[idx].interval) clearInterval(state.timers[idx].interval);
                localStorage.removeItem(`timer-${idx}`);
                state.timers[idx] = null; 
                timerDisplay.classList.remove('timer-active'); 
                timerDisplay.textContent = formatTimerDisplay(duration); 
                startBtn.classList.remove('hidden'); 
                stopBtn.classList.add('hidden'); 
            }
        }

        async function handleHistoryActions(e) { 
            const button = e.target.closest('button');
            if (!button) return;
            const historyAction = button.dataset.historyAction;
            const historyId = +button.dataset.historyId;
            if (historyAction === 'details') showHistoryDetails(historyId);
            else if (historyAction === 'delete') await deleteHistoryItem(historyId);
            else if (historyAction === 'load') {
                const historicalSession = getHistory().find(s => s.id == historyId);
                if (historicalSession) {
                    showLoadOptionsModal(historicalSession); 
                } else {
                    showNotification("SÃ©ance historique non trouvÃ©e.", "error");
                }
            }
        }

        async function deleteHistoryItem(id) {
            const confirmed = await customConfirm("Ãtes-vous sÃ»r de vouloir supprimer cette sÃ©ance de l'historique ?");
            if (confirmed) {
                let history = getHistory().filter(session => session.id != id);
                localStorage.setItem('workoutHistory', JSON.stringify(history));
                displayHistory(); 
                showNotification("SÃ©ance supprimÃ©e de l'historique.", "info");
            }
        }
        
        function updateStateFromTable() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession || !currentSession.exercises) return;

            currentSession.exercises.forEach((ex, idx) => {
                if (!ex.series) {
                    ex.series = [];
                }
                for (let i = 0; i < 5; i++) {
                    const weightInput = dom.tbody.querySelector(`.weight[data-ex='${idx}'][data-serie='${i}']`);
                    const repsInput = dom.tbody.querySelector(`.reps[data-ex='${idx}'][data-serie='${i}']`);
                    
                    if (weightInput && repsInput) {
                        if (!ex.series[i]) {
                            ex.series[i] = {};
                        }
                        ex.series[i].weight = weightInput.value;
                        ex.series[i].reps = repsInput.value;
                    }
                }
            });
        }
        
        function createTable() {
            dom.tbody.innerHTML = "";
            const exercises = state.sessions[state.currentSessionIndex]?.exercises || []; 
            exercises.forEach((ex, idx) => {
                const tr = document.createElement("tr");
                tr.className = "exercise-row";
                tr.dataset.exerciseIndex = idx;
        
                if (ex.supersetWith !== undefined && ex.supersetWith !== null) {
                    tr.classList.add('superset-group');
                    const targetEx = exercises[ex.supersetWith];
                    if(targetEx) targetEx.supersetGroup = true;
                }
                if(ex.supersetGroup) {
                    tr.classList.add('superset-group');
                }

                let seriesContentHtml = "";
                for(let i = 0; i < 5; i++) {
                    const currentSeries = ex.series?.[i] || {};
                    seriesContentHtml += `<td><div class="serie-input">
                        <input type="text" data-ex="${idx}" data-serie="${i}" class="weight" placeholder="kg" aria-label="Poids pour l'exercice ${idx+1} sÃ©rie ${i+1}" value="${currentSeries.weight || ''}">
                        <input type="text" data-ex="${idx}" data-serie="${i}" class="reps" placeholder="Reps" aria-label="Reps pour l'exercice ${idx+1} sÃ©rie ${i+1}" value="${currentSeries.reps || ''}">
                    </div></td>`;
                }
                
                tr.innerHTML = `
                    <td class="actions-col">
                        <button class="quick-edit-btn" data-action="quick-edit" aria-label="Ãdition rapide">âï¸</button>
                        <button class="link-btn" data-action="link-superset" aria-label="Lier pour superset">ð</button>
                    </td>
                    <td class="exercise-col" title="${ex.name}">
                        <span>${ex.name}</span>
                    </td>
                    ${seriesContentHtml}
                    <td id="tonnage-${idx}">0</td>
                    <td id="onerm-${idx}">0</td>
                    <td><strong>${ex.rest}</strong></td>
                    <td>
                        <div class="timer-container">
                            <div class="timer-display" id="timer-${idx}">0:00</div>
                            <button class="timer-btn" data-timer-action="start" aria-label="DÃ©marrer le minuteur">â¶</button>
                            <button class="timer-btn hidden" data-timer-action="stop" aria-label="ArrÃªter le minuteur">â </button>
                            <button class="timer-btn" data-timer-action="reset" aria-label="RÃ©initialiser le minuteur">â²</button>
                        </div>
                    </td>
                    <td><button class="btn-danger" data-action="remove">â</button></td>`;
                dom.tbody.appendChild(tr);
            });
            loadCurrentState();
            updateAllTotals();
        }

        function calculate1RM(weight, reps) {
            if (reps <= 0 || weight <= 0) return 0;
            const brzycki1RM = weight / (1.0278 - (0.0278 * reps));
            const mayhew1RM = (100 * weight) / (52.2 + (41.9 * Math.exp(-0.055 * reps)));
            return (brzycki1RM + mayhew1RM) / 2;
        }

        function updateAllTotals() {
            let totalTonnage = 0;
            let completedSeriesOverall = 0;
            const exercises = state.sessions[state.currentSessionIndex]?.exercises || [];
            let totalPossibleSeries = exercises.length * 5;
            const isValidSegment = (val) => {
                if (val === '') return true;
                const num = parseFloat(val.replace(',', '.'));
                return !isNaN(num) && num >= 0;
            };
            exercises.forEach((_, idx) => {
                let exerciseTonnage = 0;
                let exerciseMax1RM = 0;
                for (let i = 0; i < 5; i++) {
                    const repsInput = dom.tbody.querySelector(`.reps[data-ex='${idx}'][data-serie='${i}']`);
                    const weightInput = dom.tbody.querySelector(`.weight[data-ex='${idx}'][data-serie='${i}']`);
                    const repsValue = repsInput?.value.trim() || '';
                    const weightValue = weightInput?.value.trim() || '';
                    let currentSeriesTonnage = 0;
                    let currentSeriesMax1RM = 0;
                    const repsForCalculation = repsValue.split('+').map(s => parseFloat(s.replace(',', '.'))).filter(val => !isNaN(val) && val >= 0);
                    const weightsForCalculation = weightValue.split('+').map(s => parseFloat(s.replace(',', '.'))).filter(val => !isNaN(val) && val >= 0);
                    const minLength = Math.min(repsForCalculation.length, weightsForCalculation.length);
                    if (minLength > 0) {
                        for (let k = 0; k < minLength; k++) {
                            const reps = repsForCalculation[k];
                            const weight = weightsForCalculation[k];
                            currentSeriesTonnage += reps * weight;
                            const current1RM = calculate1RM(weight, reps);
                            if (current1RM > currentSeriesMax1RM) {
                                currentSeriesMax1RM = current1RM;
                            }
                        }
                    }
                    const isComplete = repsValue !== '' && weightValue !== '' && isValidSegment(repsValue) && isValidSegment(weightValue);
                    if (isComplete) {
                        repsInput.classList.add('completed');
                        weightInput.classList.add('completed');
                        completedSeriesOverall++;
                    } else {
                        repsInput?.classList.remove('completed');
                        weightInput?.classList.remove('completed');
                    }
                    exerciseTonnage += currentSeriesTonnage;
                    if (currentSeriesMax1RM > exerciseMax1RM) {
                        exerciseMax1RM = currentSeriesMax1RM;
                    }
                }
                const tonnageEl = dom.tbody.querySelector(`#tonnage-${idx}`);
                if(tonnageEl) {
                    tonnageEl.textContent = exerciseTonnage.toFixed(0);
                    tonnageEl.classList.toggle('tonnage-high', exerciseTonnage > 0);
                }
                const oneRmEl = dom.tbody.querySelector(`#onerm-${idx}`);
                if (oneRmEl) {
                    oneRmEl.textContent = exerciseMax1RM > 0 ? exerciseMax1RM.toFixed(1) : '0';
                    oneRmEl.classList.toggle('onerm-high', exerciseMax1RM > 0);
                }
                totalTonnage += exerciseTonnage;
            });
            dom.totalTonnageEl.textContent = `${totalTonnage.toFixed(0)} kg`;
            const previous = +dom.previousWeekInput.value || 0;
            const delta = totalTonnage - previous;
            const deltaSign = delta > 0 ? '+' : '';
            dom.deltaEl.textContent = `${deltaSign}${delta.toFixed(0)} kg`;
            dom.deltaEl.style.color = delta > 0 ? 'var(--success-grad-start)' : delta < 0 ? 'var(--danger-grad-start)' : 'inherit';
            dom.progressFill.style.width = `${totalPossibleSeries > 0 ? (completedSeriesOverall / totalPossibleSeries) * 100 : 0}%`;
            saveCurrentState();
        }

        function saveCurrentState() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession) return;
            currentSession.exercises.forEach((ex, idx) => {
                ex.series = Array.from({length: 5}, (_, i) => ({
                    reps: dom.tbody.querySelector(`.reps[data-ex='${idx}'][data-serie='${i}']`)?.value || '',
                    weight: dom.tbody.querySelector(`.weight[data-ex='${idx}'][data-serie='${i}']`)?.value || ''
                }));
            });
            const data = {
                previousWeek: dom.previousWeekInput.value,
                sessionIndex: state.currentSessionIndex,
                customSessions: state.sessions,
                workoutStartTime: state.workoutStartTime,
                isWorkoutTimerPaused: state.isWorkoutTimerPaused,
                pausedTime: state.isWorkoutTimerPaused ? state.pausedTime : (state.workoutStartTime ? (Date.now() - new Date(state.workoutStartTime).getTime()) / 1000 : 0),
                saveTimestamp: Date.now(),
                sessionNotes: dom.sessionNotesInput.value
            };
            localStorage.setItem('inProgressWorkout', JSON.stringify(data));
        }

        function loadCurrentState() {
            const data = JSON.parse(localStorage.getItem('inProgressWorkout'));
            if (!data) return;
            const currentExercises = state.sessions[state.currentSessionIndex]?.exercises || [];
            currentExercises.forEach((ex, idx) => {
                const repsInputs = dom.tbody.querySelectorAll(`.reps[data-ex='${idx}']`);
                const weightInputs = dom.tbody.querySelectorAll(`.weight[data-ex='${idx}']`);
                if (ex.series) {
                    ex.series.forEach((s, i) => {
                        if (repsInputs[i]) repsInputs[i].value = s.reps || '';
                        if (weightInputs[i]) weightInputs[i].value = s.weight || '';
                    });
                }
            });
            dom.previousWeekInput.value = data.previousWeek || "";
            dom.sessionNotesInput.value = data.sessionNotes || "";
        }

        function customConfirm(message) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content">
                        <p>${message}</p>
                        <div style="display: flex; justify-content: center; gap: 1rem; margin-top: 1.5rem;">
                            <button class="btn btn-danger" id="confirmNo">Non</button>
                            <button class="btn btn-success" id="confirmYes">Oui</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                document.getElementById('confirmYes').onclick = () => { modal.remove(); resolve(true); };
                document.getElementById('confirmNo').onclick = () => { modal.remove(); resolve(false); };
            });
        }
        
        function autoSaveSession() {
            if (!state.workoutStartTime || state.isWorkoutTimerPaused) {
                return;
            }
            console.log("Sauvegarde automatique de la session...");
            const workoutData = {
                id: state.workoutStartTime, 
                date: new Date().toISOString(),
                sessionName: dom.sessionSelect.selectedOptions[0].text,
                totalTonnage: +dom.totalTonnageEl.textContent.replace(' kg', ''),
                duration: dom.totalTimeEl.textContent,
                notes: dom.sessionNotesInput.value,
                isAutoSave: true,
                exercises: (state.sessions[state.currentSessionIndex]?.exercises || []).map((ex, idx) => {
                    const seriesData = [];
                    for (let i = 0; i < 5; i++) {
                        const repsInput = dom.tbody.querySelector(`.reps[data-ex='${idx}'][data-serie='${i}']`);
                        const weightInput = dom.tbody.querySelector(`.weight[data-ex='${idx}'][data-serie='${i}']`);
                        const repsValues = repsInput?.value.split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                        const weightValues = weightInput?.value.split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                        const minLength = Math.min(repsValues.length, weightValues.length);
                        for (let k = 0; k < minLength; k++) {
                            seriesData.push({ reps: repsValues[k], weight: weightValues[k] });
                        }
                    }
                    return {
                        name: ex.name,
                        rest: ex.rest || "1 min",
                        series: seriesData.filter(s => s.reps > 0 && s.weight >= 0)
                    };
                }).filter(ex => ex.series.length > 0)
            };
            let history = getHistory();
            history = history.filter(session => !(session.isAutoSave && session.id === state.workoutStartTime));
            history.push(workoutData);
            localStorage.setItem('workoutHistory', JSON.stringify(history));
            showNotification("Progression de la sÃ©ance sauvegardÃ©e automatiquement.", "info", 3000);
        }
        
        function finishAndSaveSession() {
            const totalTonnage = +dom.totalTonnageEl.textContent.replace(' kg', '');
            if (totalTonnage === 0) {
                showNotification("Aucune donnÃ©e Ã  sauvegarder. SÃ©ance non enregistrÃ©e.", "info");
                return; 
            }
            pauseTotalWorkoutTimer(); 

            const workoutData = {
                id: Date.now(),
                date: new Date().toISOString(),
                sessionName: dom.sessionSelect.selectedOptions[0].text,
                totalTonnage,
                duration: dom.totalTimeEl.textContent,
                notes: dom.sessionNotesInput.value,
                exercises: (state.sessions[state.currentSessionIndex]?.exercises || []).map((ex, idx) => {
                    const seriesData = [];
                    for (let i = 0; i < 5; i++) {
                        const repsInput = dom.tbody.querySelector(`.reps[data-ex='${idx}'][data-serie='${i}']`);
                        const weightInput = dom.tbody.querySelector(`.weight[data-ex='${idx}'][data-serie='${i}']`);
                        const repsValues = repsInput?.value.split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                        const weightValues = weightInput?.value.split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                        const minLength = Math.min(repsValues.length, weightValues.length);
                        for (let k = 0; k < minLength; k++) {
                            seriesData.push({ reps: repsValues[k], weight: weightValues[k] });
                        }
                    }
                    return {
                        name: ex.name,
                        rest: ex.rest || "1 min",
                        series: seriesData.filter(s => s.reps > 0 && s.weight >= 0)
                    };
                }).filter(ex => ex.series.length > 0)
            };
            let history = getHistory();
            history = history.filter(session => !(session.isAutoSave && session.id === state.workoutStartTime));
            history.push(workoutData);
            localStorage.setItem('workoutHistory', JSON.stringify(history));
            showNotification("SÃ©ance sauvegardÃ©e dans l'historique !", "success");
            
            Object.values(state.timers).forEach(timer => {
                if (timer && timer.interval) clearInterval(timer.interval);
            });
            state.timers = {};
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.toggleWorkoutTimerBtn.textContent = 'â¶ï¸ Play';
            localStorage.removeItem('inProgressWorkout');
            createTable();
            dom.totalTimeEl.textContent = "00:00:00";
            dom.totalTonnageEl.textContent = "0 kg";
            dom.deltaEl.textContent = "0 kg";
            dom.previousWeekInput.value = "";
            dom.sessionNotesInput.value = "";
        }

        function getHistory() { return JSON.parse(localStorage.getItem('workoutHistory')) || []; }
        
        function displayHistory() {
            dom.historyList.innerHTML = '';
            getHistory().sort((a, b) => new Date(b.date) - new Date(a.date)).forEach(session => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.innerHTML = `
                    <div>
                        ${new Date(session.date).toLocaleDateString('fr-FR')} - 
                        <strong>${session.sessionName}</strong> (${session.totalTonnage} kg)
                        ${session.duration ? ` - â±ï¸ ${session.duration}` : ''}
                    </div>
                    <div>
                        <button class="btn btn-info" data-history-action="details" data-history-id="${session.id}">DÃ©tails</button>
                        <button class="btn btn-success" data-history-action="load" data-history-id="${session.id}">Utiliser</button>
                        <button class="btn btn-danger" data-history-action="delete" data-history-id="${session.id}">Supprimer</button>
                    </div>
                    <div class="history-details" id="details-${session.id}"></div>`;
                dom.historyList.appendChild(item);
            });
        }
        
        function showHistoryDetails(id) {
            const detailsDiv = document.getElementById(`details-${id}`);
            detailsDiv.classList.toggle('visible');
            if (detailsDiv.classList.contains('visible')) {
                const session = getHistory().find(s => s.id == id);
                if (session) {
                    let detailsHtml = `<h4>DÃ©tails de la SÃ©ance :</h4>
                                       <p><strong>Tonnage Total :</strong> ${session.totalTonnage} kg</p>
                                       <ul>`;
                    session.exercises.forEach(ex => {
                        let exerciseMax1RM = 0;
                        if (ex.series && ex.series.length > 0) {
                            ex.series.forEach(s => {
                                const reps = parseFloat(s.reps) || 0;
                                const weight = parseFloat(s.weight) || 0;
                                if (reps > 0 && weight > 0) {
                                    const oneRM = calculate1RM(weight, reps);
                                    if (oneRM > exerciseMax1RM) {
                                        exerciseMax1RM = oneRM;
                                    }
                                }
                            });
                        }
                        detailsHtml += `<li><strong>${ex.name}</strong> - 1RM Max: ${exerciseMax1RM.toFixed(1)} kg</li>`;
                    });
                    detailsHtml += '</ul>';
                    detailsDiv.innerHTML = detailsHtml;
                }
            } else {
                detailsDiv.innerHTML = '';
            }
        }

        function exportCSV() {
            let csvContent = "DateSession;NomSeance;DureeTotaleSeance;Exercice;Serie;Reps;Poids;Notes\n";
            const history = getHistory();
            if (history.length === 0) {
                showNotification("Aucune donnÃ©e historique Ã  exporter.", "info");
                return;
            }

            history.forEach(session => {
                let isFirstLineOfSession = true;
                const sessionDate = new Date(session.date).toLocaleDateString('fr-FR', {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit'
                }).replace(/,/g, '');
                const sessionName = `"${session.sessionName.replace(/"/g, '""')}"`;
                const sessionDuration = session.duration || '';
                const sessionNotes = `"${(session.notes || '').replace(/"/g, '""')}"`;

                if (session.exercises.length === 0) {
                    csvContent += `${sessionDate};${sessionName};${sessionDuration};;;;;${sessionNotes}\n`;
                } else {
                    session.exercises.forEach(ex => {
                        const exerciseName = `"${ex.name.replace(/"/g, '""')}"`;
                        if (ex.series.length === 0) {
                             if (isFirstLineOfSession) {
                                csvContent += `${sessionDate};${sessionName};${sessionDuration};${exerciseName};;;;${sessionNotes}\n`;
                                isFirstLineOfSession = false;
                            } else {
                                csvContent += `;;;${exerciseName};;;;\n`;
                            }
                        } else {
                            ex.series.forEach((serieData, i) => {
                                const reps = serieData.reps;
                                const weight = String(serieData.weight).replace('.', ',');
                                if (isFirstLineOfSession) {
                                    csvContent += `${sessionDate};${sessionName};${sessionDuration};${exerciseName};SÃ©rie ${i + 1};${reps};${weight};${sessionNotes}\n`;
                                    isFirstLineOfSession = false;
                                } else {
                                    csvContent += `;;;${exerciseName};SÃ©rie ${i + 1};${reps};${weight};\n`;
                                }
                            });
                        }
                    });
                }
            });

            const blob = new Blob([new Uint8Array([0xEF, 0xBB, 0xBF]), csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `historique_seances_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
            URL.revokeObjectURL(link.href);
            showNotification("Exportation de l'historique CSV rÃ©ussie !", "success");
        }

        
        function showNotification(message, type = 'info', duration = 5000) { 
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `<span>${message}</span>`;
            dom.notificationContainer.appendChild(notification);
            void notification.offsetWidth;
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
                notification.addEventListener('transitionend', () => notification.remove(), { once : true });
            }, duration);
        }

        function showUndoableNotification(message, onUndoCallback, duration = 7000) {
            const notification = document.createElement('div');
            notification.className = `notification info`; 
            notification.innerHTML = `
                <span>${message}</span>
                <button class="btn btn-secondary" id="undoBtn" style="margin-left: 1rem; padding: 0.5rem 1rem; border-radius: 15px;">Annuler</button>
            `;
            dom.notificationContainer.appendChild(notification);
            void notification.offsetWidth; 
            notification.classList.add('show');
            let timer; 
            const closeNotification = () => {
                notification.classList.remove('show');
                notification.addEventListener('transitionend', () => notification.remove(), { once : true });
            };
            const undoButton = notification.querySelector('#undoBtn');
            if (undoButton) {
                undoButton.addEventListener('click', () => {
                    clearTimeout(timer); 
                    onUndoCallback(); 
                    closeNotification(); 
                });
            }
            timer = setTimeout(closeNotification, duration);
        }

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }
        
        function formatTimerDisplay(seconds) {
             const m = Math.floor(seconds / 60);
             const s = Math.floor(seconds % 60);
             return `${m}:${String(s).padStart(2, '0')}`;
        }

        function updateTotalTimeDisplay() {
            if (!state.workoutStartTime) {
                dom.totalTimeEl.textContent = "00:00:00";
                return;
            }
            const elapsedSeconds = state.isWorkoutTimerPaused ? state.pausedTime : (Date.now() - new Date(state.workoutStartTime).getTime()) / 1000;
            dom.totalTimeEl.textContent = formatTime(elapsedSeconds);
        }
        
        function resetInactivityTimer() {
            clearTimeout(state.inactivityTimeout);
            if (state.workoutStartTime && !state.isWorkoutTimerPaused) {
                state.inactivityTimeout = setTimeout(() => {
                    pauseTotalWorkoutTimer();
                    showNotification("Minuteur mis en pause pour inactivitÃ©.", "info");
                }, 600000); // 10 minutes
            }
        }

        function startInactivityAndAutoSaveTimers() {
            resetInactivityTimer();
            if (state.autoSaveInterval) clearInterval(state.autoSaveInterval);
            state.autoSaveInterval = setInterval(autoSaveSession, 2400000); // 40 minutes
            document.addEventListener('mousemove', resetInactivityTimer);
            document.addEventListener('keydown', resetInactivityTimer);
            document.addEventListener('click', resetInactivityTimer);
        }

        function stopInactivityAndAutoSaveTimers() {
            clearTimeout(state.inactivityTimeout);
            clearInterval(state.autoSaveInterval);
            state.autoSaveInterval = null;
            document.removeEventListener('mousemove', resetInactivityTimer);
            document.removeEventListener('keydown', resetInactivityTimer);
            document.removeEventListener('click', resetInactivityTimer);
        }

        function startTotalWorkoutTimer() {
            if (state.totalWorkoutTimeInterval) clearInterval(state.totalWorkoutTimeInterval);

            if (!state.workoutStartTime) {
                 state.workoutStartTime = new Date().toISOString();
                 state.pausedTime = 0; 
            } else if (state.isWorkoutTimerPaused) {
                state.workoutStartTime = new Date(Date.now() - state.pausedTime * 1000).toISOString();
            }
            
            state.isWorkoutTimerPaused = false;
            state.totalWorkoutTimeInterval = setInterval(updateTotalTimeDisplay, 1000);
            startInactivityAndAutoSaveTimers();
            updateTotalTimeDisplay(); 
            dom.toggleWorkoutTimerBtn.textContent = 'â¸ï¸ Pause';
            saveCurrentState();
        }

        function pauseTotalWorkoutTimer() {
            if (state.totalWorkoutTimeInterval) {
                clearInterval(state.totalWorkoutTimeInterval);
                state.totalWorkoutTimeInterval = null;
            }
            if (state.workoutStartTime) {
                state.pausedTime = (Date.now() - new Date(state.workoutStartTime).getTime()) / 1000;
            }
            state.isWorkoutTimerPaused = true;
            stopInactivityAndAutoSaveTimers();
            dom.toggleWorkoutTimerBtn.textContent = 'â¶ï¸ Play';
            updateTotalTimeDisplay(); 
            saveCurrentState();
        }

        function applyTheme(theme) {
            if (theme === 'dark') {
                dom.body.classList.add('dark-mode');
                dom.themeToggleBtn.textContent = 'âï¸';
            } else {
                dom.body.classList.remove('dark-mode');
                dom.themeToggleBtn.textContent = 'ð';
            }
        }

        function updateSessionSelectOptions() {
            dom.sessionSelect.innerHTML = '';
            state.sessions.forEach((session, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = session.name; 
                dom.sessionSelect.appendChild(option);
            });
        }

        function showNewSessionModal() {
            dom.newSessionModal.classList.remove('hidden');
            dom.newSessionNameInput.value = ''; 
            dom.newSessionNameInput.focus(); 
        }

        function hideNewSessionModal() {
            dom.newSessionModal.classList.add('hidden');
        }

        async function createNewSession() {
            const newName = dom.newSessionNameInput.value.trim();
            if (!newName) {
                showNotification("Veuillez entrer un nom pour la nouvelle sÃ©ance.", "error");
                return;
            }
            const isDuplicate = state.sessions.some(s => s.name.toLowerCase() === newName.toLowerCase());
            if (isDuplicate) {
                showNotification(`Une sÃ©ance nommÃ©e "${newName}" existe dÃ©jÃ .`, "error");
                return;
            }
            const newSession = { name: newName, exercises: [] };
            state.sessions.push(newSession);
            updateSessionSelectOptions(); 
            state.currentSessionIndex = state.sessions.length - 1; 
            dom.sessionSelect.value = state.currentSessionIndex;
            localStorage.removeItem('inProgressWorkout');
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.totalTimeEl.textContent = "00:00:00";
            dom.toggleWorkoutTimerBtn.textContent = 'â¶ï¸ Play';
            createTable(); 
            updateAllTotals(); 
            showNotification(`SÃ©ance "${newName}" crÃ©Ã©e avec succÃ¨s !`, "success");
            hideNewSessionModal();
        }

        async function openNewSessionLogic(historicalSession) {
            const confirmed = await customConfirm("Ouvrir cette sÃ©ance ? La sÃ©ance en cours sera remplacÃ©e.");
            if (!confirmed) return;
            Object.values(state.timers).forEach(timer => {
                if (timer && timer.interval) clearInterval(timer.interval);
            });
            state.timers = {};
            if (state.totalWorkoutTimeInterval) {
                clearInterval(state.totalWorkoutTimeInterval);
                state.totalWorkoutTimeInterval = null;
            }
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.toggleWorkoutTimerBtn.textContent = 'â¶ï¸ Play';
            localStorage.removeItem('inProgressWorkout');
            dom.totalTimeEl.textContent = "00:00:00";
            dom.totalTonnageEl.textContent = "0 kg";
            dom.deltaEl.textContent = "0 kg";
            dom.previousWeekInput.value = "";
            dom.sessionNotesInput.value = ""; 
            let sessionIndexToLoad = state.sessions.findIndex(s => s.name === historicalSession.sessionName);
            if (sessionIndexToLoad === -1) {
                const newTemplateExercises = historicalSession.exercises.map(ex => ({
                    name: ex.name,
                    rest: ex.rest || "1 min",
                    series: ex.series || []
                }));
                const newTemplate = { name: historicalSession.sessionName, exercises: newTemplateExercises };
                state.sessions.push(newTemplate);
                sessionIndexToLoad = state.sessions.length - 1;
                updateSessionSelectOptions(); 
            } else {
                state.sessions[sessionIndexToLoad].exercises = historicalSession.exercises.map(ex => ({
                    name: ex.name,
                    rest: ex.rest || "1 min",
                    series: ex.series || []
                }));
            }
            state.currentSessionIndex = sessionIndexToLoad;
            dom.sessionSelect.value = state.currentSessionIndex; 
            createTable();
            dom.previousWeekInput.value = historicalSession.totalTonnage; 
            dom.sessionNotesInput.value = historicalSession.notes || ""; 
            updateAllTotals(); 
            showNotification(`SÃ©ance "${historicalSession.sessionName}" ouverte.`, "success", 3000);
            dom.loadOptionsModal.classList.add('hidden'); 
            dom.historyModal.classList.add('hidden');
        }

        async function appendToCurrentSessionLogic(historicalSession) {
            const confirmed = await customConfirm("Ajouter/mettre Ã  jour les exercices de cette sÃ©ance Ã  la sÃ©ance en cours ?");
            if (!confirmed) return;
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession.exercises) {
                currentSession.exercises = []; 
            }
            let exercisesAdded = 0;
            let exercisesUpdated = 0;
            historicalSession.exercises.forEach(historicalEx => {
                const existingExIndex = currentSession.exercises.findIndex(ex => ex.name === historicalEx.name);
                if (existingExIndex !== -1) {
                    const currentEx = currentSession.exercises[existingExIndex];
                    currentEx.series = JSON.parse(JSON.stringify(historicalEx.series));
                    exercisesUpdated++;
                } else {
                    currentSession.exercises.push(JSON.parse(JSON.stringify(historicalEx)));
                    exercisesAdded++;
                }
            });
            createTable(); 
            dom.previousWeekInput.value = historicalSession.totalTonnage; 
            dom.sessionNotesInput.value = historicalSession.notes || ""; 
            updateAllTotals(); 
            showNotification(`${exercisesAdded} exercices ajoutÃ©s et ${exercisesUpdated} mis Ã  jour dans la sÃ©ance en cours.`, "success", 5000);
            dom.loadOptionsModal.classList.add('hidden'); 
            dom.historyModal.classList.add('hidden');
        }

        function showLoadOptionsModal(session) {
            state.sessionToLoad = session; 
            dom.loadSessionNameDisplay.textContent = session.sessionName;
            dom.loadOptionsModal.classList.remove('hidden');
        }

        function hideLoadOptionsModal() {
            dom.loadOptionsModal.classList.add('hidden');
            state.sessionToLoad = null; 
        }

        function parseExerciseList(rawList) {
            return rawList.split('\n')
                .map(line => line.trim())
                .filter(line => line && !line.startsWith('--- PAGE') && !line.startsWith('Liste des Exercices'))
                .map(line => line.replace(/\s\s+/g, ' ').trim()); 
        }

        function showSuggestions(input) {
            const query = input.value.toLowerCase();
            dom.autocompleteSuggestions.innerHTML = '';
            if (query.length < 2) { 
                dom.autocompleteSuggestions.classList.add('hidden');
                return;
            }
            const filteredSuggestions = state.availableExercises.filter(exercise => 
                exercise.toLowerCase().includes(query)
            ).slice(0, 10); 
            if (filteredSuggestions.length > 0) {
                filteredSuggestions.forEach(suggestion => {
                    const div = document.createElement('div');
                    div.textContent = suggestion;
                    div.addEventListener('click', () => {
                        input.value = suggestion;
                        dom.autocompleteSuggestions.classList.add('hidden');
                        dom.autocompleteSuggestions.innerHTML = ''; 
                    });
                    dom.autocompleteSuggestions.appendChild(div);
                });
                dom.autocompleteSuggestions.classList.remove('hidden');
            } else {
                dom.autocompleteSuggestions.classList.add('hidden');
            }
        }

        function hideSuggestionsOnClickOutside(event) {
            if (!dom.autocompleteSuggestions.contains(event.target) && event.target !== dom.customExerciseInput) {
                dom.autocompleteSuggestions.classList.add('hidden');
            }
        }

        function playBeep() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.type = 'sine'; 
                oscillator.frequency.setValueAtTime(500, audioContext.currentTime); 
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.01); 
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5); 
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5); 
            } catch (error) {
                console.warn("Could not play sound: AudioContext not supported or blocked.", error);
            }
        }
        
        function setupEventListeners() {
            dom.sessionSelect.addEventListener('change', async () => {
                const lastSavedIndex = state.currentSessionIndex;
                if (localStorage.getItem('inProgressWorkout')) {
                    const confirmed = await customConfirm("Changer de sÃ©ance annulera la sÃ©ance en cours. Continuer ?");
                    if (!confirmed) {
                        dom.sessionSelect.value = lastSavedIndex;
                        return;
                    }
                    Object.values(state.timers).forEach(timer => clearInterval(timer.interval));
                    state.timers = {};
                    if (state.totalWorkoutTimeInterval) {
                        clearInterval(state.totalWorkoutTimeInterval);
                        state.totalWorkoutTimeInterval = null;
                    }
                    state.workoutStartTime = null;
                    state.isWorkoutTimerPaused = false;
                    state.pausedTime = 0;
                    dom.toggleWorkoutTimerBtn.textContent = 'â¶ï¸ Play';
                    localStorage.removeItem('inProgressWorkout');
                    dom.totalTimeEl.textContent = "00:00:00";
                    dom.totalTonnageEl.textContent = "0 kg"; 
                    dom.deltaEl.textContent = "0 kg"; 
                    dom.previousWeekInput.value = "";
                    dom.sessionNotesInput.value = ""; 
                }
                state.currentSessionIndex = +dom.sessionSelect.value;
                createTable();
            });
            
            document.getElementById('addExerciseBtn').addEventListener('click', () => {
                const name = dom.customExerciseInput.value.trim();
                if (name) {
                    updateStateFromTable();
                    if (!state.sessions[state.currentSessionIndex].exercises) {
                        state.sessions[state.currentSessionIndex].exercises = [];
                    }
                    state.sessions[state.currentSessionIndex].exercises.push({ name, rest: "1 min", series: [] });
                    createTable(); 
                    dom.customExerciseInput.value = '';
                    showNotification(`Exercice "${name}" ajoutÃ©.`, "info");
                    dom.autocompleteSuggestions.classList.add('hidden'); 
                    const newRow = dom.tbody.lastElementChild;
                    if (newRow) {
                        newRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                } else {
                    showNotification("Veuillez entrer un nom d'exercice.", "error");
                }
            });

            dom.customExerciseInput.addEventListener('input', () => showSuggestions(dom.customExerciseInput));
            dom.customExerciseInput.addEventListener('blur', () => {
                setTimeout(() => dom.autocompleteSuggestions.classList.add('hidden'), 100); 
            });
            dom.customExerciseInput.addEventListener('focus', () => showSuggestions(dom.customExerciseInput));
            document.addEventListener('click', hideSuggestionsOnClickOutside);
            dom.autocompleteSuggestions.addEventListener('mousedown', (e) => e.preventDefault());

            dom.tbody.addEventListener('blur', (e) => {
                if (e.target.classList.contains('reps')) {
                    handleRepInput(e);
                }
            }, true);


            dom.tbody.addEventListener('change', e => {
                if (e.target.classList.contains('reps') || e.target.classList.contains('weight')) {
                    if (!state.workoutStartTime) {
                        startTotalWorkoutTimer();
                    }
                    updateAllTotals();

                    const row = e.target.closest('.exercise-row');
                    const exIndex = parseInt(row.dataset.exerciseIndex, 10);
                    const serieIndex = parseInt(e.target.dataset.serie, 10);
                    
                    const repsInput = row.querySelector(`.reps[data-ex='${exIndex}'][data-serie='${serieIndex}']`);
                    const weightInput = row.querySelector(`.weight[data-ex='${exIndex}'][data-serie='${serieIndex}']`);

                    if (repsInput && weightInput && repsInput.value.trim() !== '' && weightInput.value.trim() !== '') {
                        
                        const exercises = state.sessions[state.currentSessionIndex].exercises;
                        const currentExercise = exercises[exIndex];

                        const nextWeightInput = row.querySelector(`.weight[data-ex='${exIndex}'][data-serie='${serieIndex + 1}']`);
                        if (nextWeightInput && nextWeightInput.value.trim() === '') {
                            nextWeightInput.value = weightInput.value;
                        }

                        if (row.classList.contains('next-superset-exercise')) {
                            row.classList.remove('next-superset-exercise');
                        }

                        if (currentExercise.supersetWith !== undefined && currentExercise.supersetWith !== null) {
                            document.querySelectorAll('.next-superset-exercise').forEach(el => el.classList.remove('next-superset-exercise'));
                            const nextExIndex = currentExercise.supersetWith;
                            const nextRow = dom.tbody.querySelector(`[data-exercise-index="${nextExIndex}"]`);
                            if (nextRow) {
                                nextRow.classList.add('next-superset-exercise');
                                showNotification(`Exercice Suivant: ${exercises[nextExIndex].name}`, "info");
                            }
                            return;
                        }

                        const parentExerciseIndex = exercises.findIndex(ex => ex.supersetWith === exIndex);
                        if (parentExerciseIndex !== -1) {
                            row.classList.remove('next-superset-exercise');
                            handleTimerActions('start', exIndex, row);
                        }
                    }
                }
            });

            dom.previousWeekInput.addEventListener('input', updateAllTotals); 
            dom.tbody.addEventListener('click', handleTableActions);
            document.getElementById('finishSessionBtn').addEventListener('click', finishAndSaveSession);
            document.getElementById('viewHistoryBtn').addEventListener('click', () => {
                displayHistory(); 
                dom.historyModal.classList.remove('hidden'); 
            });
            dom.historyModal.addEventListener('click', handleHistoryActions);
            document.getElementById('exportBtn').addEventListener('click', exportCSV);
            dom.importFileInput.addEventListener('change', async (event) => { 
                const file = event.target.files[0];
                if (!file) {
                    showNotification("Aucun fichier sÃ©lectionnÃ©.", "info");
                    return;
                }
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const content = e.target.result;
                        let importedDataAddedToHistory = false;
                        if (file.type === 'application/json') {
                            const importedHistory = JSON.parse(content);
                            const hasValidWorkoutStructure = Array.isArray(importedHistory) && importedHistory.every(session => {
                                if (!session.sessionName || typeof session.totalTonnage === 'undefined' || typeof session.duration === 'undefined' || !Array.isArray(session.exercises)) return false;
                                return session.exercises.every(exercise => {
                                    if (!exercise.name || typeof exercise.rest === 'undefined' || !Array.isArray(exercise.series)) return false;
                                    return exercise.series.every(serie => typeof serie.reps === 'number' && typeof serie.weight === 'number');
                                });
                            });
                            if (!hasValidWorkoutStructure) {
                                showNotification("Le fichier JSON importÃ© ne correspond pas au format attendu. Veuillez vÃ©rifier sa structure.", "error", 5000);
                                return; 
                            }
                            const confirmed = await customConfirm("Importer l'historique ? Cela remplacera l'historique actuel.");
                            if (confirmed) {
                                localStorage.setItem('workoutHistory', JSON.stringify(importedHistory));
                                importedDataAddedToHistory = true;
                                displayHistory(); 
                            } else {
                                showNotification("Importation annulÃ©e.", "info");
                            }
                        } else if (file.type === 'text/csv') {
                            const lines = content.split('\n').filter(line => line.trim() !== '');
                            if (lines.length <= 1) { 
                                showNotification("Le fichier CSV est vide ou ne contient aucune donnÃ©e.", "error");
                                return;
                            }
                            const importedSessionsMap = new Map(); 
                            const header = lines[0].trim();
                            const expectedHeaders = { 'full_export_new_v2': "DateSession;NomSeance;DureeTotaleSeance;Exercice;Serie;Reps;Poids" };
                            let selectedHeaderType = null;
                            if (header === expectedHeaders.full_export_new_v2) {
                                selectedHeaderType = 'full_export_new_v2';
                            } else {
                                showNotification(`En-tÃªte CSV inattendu. Le format d'importation actuel est : "${expectedHeaders.full_export_new_v2}".`, "error", 7000);
                                return;
                            }
                            for (let i = 1; i < lines.length; i++) {
                                const line = lines[i].trim();
                                if (!line) continue;
                                const parts = line.split(';');
                                let dateStr, sessionName, totalSessionTonnage, sessionDuration, exerciseName, serieIndex, reps, weight;
                                if (selectedHeaderType === 'full_export_new_v2') {
                                    if (parts.length < 7) { 
                                        showNotification(`Ligne CSV invalide : "${line}".`, "warning", 7000);
                                        continue;
                                    }
                                    dateStr = parts[0].trim(); 
                                    sessionName = parts[1].replace(/"/g, '').trim();
                                    sessionDuration = parts[2].trim();
                                    exerciseName = parts[3].replace(/"/g, '').trim();
                                    serieIndex = parseInt(parts[4].replace('SÃ©rie ', ''), 10) - 1;
                                    reps = parseInt(parts[5], 10);
                                    weight = parseFloat(parts[6].replace(',', '.'));
                                    totalSessionTonnage = 0;
                                }
                                if (isNaN(serieIndex) || (serieIndex < 0 || serieIndex >= 5) || isNaN(reps) || isNaN(weight)) {
                                    showNotification(`DonnÃ©es numÃ©riques invalides dans la ligne CSV : "${line}".`, "warning", 7000);
                                    continue;
                                }
                                const dateParseString = dateStr.replace(/(\d{2})\/(\d{2})\/(\d{4}) (\d{2}):(\d{2})/, '$3-$2-$1T$4:$5:00'); 
                                const sessionKey = `${dateParseString}_${sessionName}`;
                                if (!importedSessionsMap.has(sessionKey)) {
                                    importedSessionsMap.set(sessionKey, { id: Date.now() + importedSessionsMap.size, date: new Date(dateParseString).toISOString(), sessionName: sessionName, totalTonnage: totalSessionTonnage, duration: sessionDuration, notes: "", exercises: [] });
                                }
                                const sessionData = importedSessionsMap.get(sessionKey);
                                let exerciseData = sessionData.exercises.find(ex => ex.name === exerciseName);
                                if (!exerciseData) {
                                    exerciseData = { name: exerciseName, rest: "1 min", series: Array(5).fill(null).map(() => ({ reps: '', weight: '' })) };
                                    sessionData.exercises.push(exerciseData);
                                }
                                if (exerciseData.series[serieIndex].reps === '' && exerciseData.series[serieIndex].weight === '') {
                                    exerciseData.series[serieIndex].reps = String(reps);
                                    exerciseData.series[serieIndex].weight = String(weight);
                                } else {
                                    exerciseData.series[serieIndex].reps += `+${reps}`;
                                    exerciseData.series[serieIndex].weight += `+${weight}`;
                                }
                            }
                            importedSessionsMap.forEach(sessionData => {
                                let calculatedTonnage = 0;
                                sessionData.exercises.forEach(ex => {
                                    ex.series.forEach(serie => {
                                        const repsValues = String(serie.reps).split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val > 0) || [];
                                        const weightValues = String(serie.weight).split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val > 0) || [];
                                        const minLength = Math.min(repsValues.length, weightValues.length);
                                        for (let k = 0; k < minLength; k++) {
                                            calculatedTonnage += (repsValues[k] || 0) * (weightValues[k] || 0);
                                        }
                                    });
                                });
                                sessionData.totalTonnage = calculatedTonnage;
                            });
                            const importedHistory = Array.from(importedSessionsMap.values());
                            if (importedHistory.length > 0) {
                                const confirmed = await customConfirm("Importer l'historique CSV ? Cela ajoutera les sÃ©ances importÃ©es Ã  l'historique actuel.");
                                if (confirmed) {
                                    let currentHistory = getHistory();
                                    const newHistory = [...currentHistory];
                                    importedHistory.forEach(importedSession => {
                                        if (!newHistory.some(existingSession => existingSession.id === importedSession.id)) {
                                            newHistory.push(importedSession);
                                        }
                                    });
                                    localStorage.setItem('workoutHistory', JSON.stringify(newHistory));
                                    importedDataAddedToHistory = true;
                                    displayHistory(); 
                                } else {
                                    showNotification("Importation annulÃ©e.", "info");
                                }
                            } else {
                                showNotification("Aucune donnÃ©e valide trouvÃ©e dans le fichier CSV pour l'importation.", "info", 5000);
                            }
                        } else {
                            showNotification("Type de fichier non pris en charge. Veuillez importer un fichier JSON ou CSV.", "error");
                        }
                        if (importedDataAddedToHistory) {
                            showNotification("SÃ©ance(s) importÃ©e(s) dans l'historique. Utilisez l'option 'Historique' pour les charger.", "success", 5000);
                        }
                    } catch (error) {
                        console.error("Erreur lors de la lecture ou de l'analyse du fichier :", error);
                        showNotification("Erreur lors de la lecture ou de l'analyse du fichier. Assurez-vous qu'il est valide.", "error");
                    } finally {
                        dom.importFileInput.value = ''; 
                    }
                }; 
                reader.onerror = (error) => {
                    console.error("Erreur FileReader :", error);
                    showNotification("Erreur lors de la lecture du fichier.", "error");
                };
                reader.readAsText(file);
            });
            document.getElementById('importBtn').addEventListener('click', () => dom.importFileInput.click()); 
            document.getElementById('closeHistoryModal').addEventListener('click', () => dom.historyModal.classList.add('hidden'));
            dom.themeToggleBtn.addEventListener('click', () => {
                const newTheme = dom.body.classList.contains('dark-mode') ? 'light' : 'dark';
                applyTheme(newTheme);
                localStorage.setItem('theme', newTheme);
            });
            dom.toggleWorkoutTimerBtn.addEventListener('click', () => {
                if (state.isWorkoutTimerPaused) {
                    startTotalWorkoutTimer();
                } else {
                    pauseTotalWorkoutTimer();
                }
            });
            dom.createNewSessionTypeBtn.addEventListener('click', showNewSessionModal);
            dom.closeNewSessionModal.addEventListener('click', hideNewSessionModal);
            dom.cancelNewSessionBtn.addEventListener('click', hideNewSessionModal);
            dom.createNewSessionBtn.addEventListener('click', createNewSession);
            dom.closeLoadOptionsModal.addEventListener('click', hideLoadOptionsModal);
            dom.openNewSessionBtn.addEventListener('click', async () => { 
                if (state.sessionToLoad) await openNewSessionLogic(state.sessionToLoad);
            });
            dom.appendToCurrentSessionBtn.addEventListener('click', async () => { 
                if (state.sessionToLoad) await appendToCurrentSessionLogic(state.sessionToLoad);
            });
            dom.plateCalculatorBtn.addEventListener('click', () => {
                dom.plateCalculatorModal.classList.remove('hidden');
                dom.targetWeightInput.value = '';
                dom.barbellWeightInput.value = '';
                dom.oneRmInput.value = '';
                dom.platesResult.innerHTML = '';
                dom.goalResultsContainer.innerHTML = '';
            });
            dom.closePlateCalculatorModal.addEventListener('click', () => dom.plateCalculatorModal.classList.add('hidden'));
            dom.targetWeightInput.addEventListener('input', calculatePlates);
            dom.barbellWeightInput.addEventListener('input', calculatePlates);
            
            // New Event Listeners for Goal Calculator
            dom.plateCalcTab.addEventListener('click', () => {
                dom.plateCalcTab.classList.add('active');
                dom.goalCalcTab.classList.remove('active');
                dom.plateCalcContent.classList.remove('hidden');
                dom.goalCalcContent.classList.add('hidden');
            });

            dom.goalCalcTab.addEventListener('click', () => {
                dom.goalCalcTab.classList.add('active');
                dom.plateCalcTab.classList.remove('active');
                dom.goalCalcContent.classList.remove('hidden');
                dom.plateCalcContent.classList.add('hidden');
            });

            dom.oneRmInput.addEventListener('input', calculateTrainingGoals);

            // Quick Edit Modal Listeners
            dom.closeQuickEditModal.addEventListener('click', () => dom.quickEditModal.classList.add('hidden'));
            dom.applyQuickEditBtn.addEventListener('click', () => {
                if (state.quickEditIndex !== null) {
                    const weight = dom.quickEditWeight.value;
                    const reps = dom.quickEditReps.value;
                    for (let i = 0; i < 5; i++) {
                        const weightInput = dom.tbody.querySelector(`.weight[data-ex='${state.quickEditIndex}'][data-serie='${i}']`);
                        const repsInput = dom.tbody.querySelector(`.reps[data-ex='${state.quickEditIndex}'][data-serie='${i}']`);
                        if(weightInput) weightInput.value = weight;
                        if(repsInput) repsInput.value = reps;
                    }
                    updateAllTotals();
                    dom.quickEditModal.classList.add('hidden');
                    showNotification("SÃ©ries mises Ã  jour rapidement !", "success");
                }
            });

            document.addEventListener('keydown', e => {
                if (e.ctrlKey || e.metaKey) { 
                    if (e.key === 's') { e.preventDefault(); finishAndSaveSession(); } 
                    if (e.key === 'e') { e.preventDefault(); exportCSV(); } 
                }
                if (e.key === 'Escape') { 
                    if (!dom.historyModal.classList.contains('hidden')) dom.historyModal.classList.add('hidden');
                    if (!dom.newSessionModal.classList.contains('hidden')) dom.newSessionModal.classList.add('hidden');
                    if (!dom.loadOptionsModal.classList.contains('hidden')) hideLoadOptionsModal();
                    if (!dom.plateCalculatorModal.classList.contains('hidden')) dom.plateCalculatorModal.classList.add('hidden');
                    if (!dom.quickEditModal.classList.contains('hidden')) dom.quickEditModal.classList.add('hidden');
                }
            });
        }
        
        function init() {
            if ('Notification' in window) {
                Notification.requestPermission();
            }

            state.availableExercises = parseExerciseList(rawExerciseList);

            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                applyTheme(savedTheme);
            } else {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
                applyTheme(prefersDark.matches ? 'dark' : 'light');
                prefersDark.addEventListener('change', (e) => {
                    if (!localStorage.getItem('theme')) {
                        applyTheme(e.matches ? 'dark' : 'light');
                    }
                });
            }
            
            const inProgress = JSON.parse(localStorage.getItem('inProgressWorkout'));
            if (inProgress) {
                state.sessions = inProgress.customSessions || JSON.parse(JSON.stringify(defaultSessions));
                state.currentSessionIndex = inProgress.sessionIndex || 0;
                if (state.currentSessionIndex >= state.sessions.length) {
                    state.currentSessionIndex = 0;
                }
                
                state.workoutStartTime = inProgress.workoutStartTime || null;
                state.isWorkoutTimerPaused = inProgress.isWorkoutTimerPaused;
                state.pausedTime = inProgress.pausedTime || 0;
                
                if (state.workoutStartTime && !state.isWorkoutTimerPaused) {
                    const elapsedSinceSave = (Date.now() - (inProgress.saveTimestamp || new Date(state.workoutStartTime).getTime())) / 1000;
                    state.pausedTime = (inProgress.pausedTime || 0);
                    startTotalWorkoutTimer();
                } else if (state.workoutStartTime) {
                    dom.totalTimeEl.textContent = formatTime(state.pausedTime);
                    dom.toggleWorkoutTimerBtn.textContent = 'â¶ï¸ Play';
                }
            } else {
                 state.sessions = JSON.parse(JSON.stringify(defaultSessions));
            }
            
            updateSessionSelectOptions(); 
            dom.sessionSelect.value = state.currentSessionIndex;
            createTable();
            setupEventListeners();
        }

        init();
    });
    </script>
</body>
</html>
